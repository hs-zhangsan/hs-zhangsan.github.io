{"title":"142-环形链表II","date":"2023-01-29T11:41:43.000Z","date_formatted":{"ll":"Jan 29, 2023","L":"01/29/2023","MM-DD":"01-29"},"updated":"2023-03-31T11:45:37.365Z","content":"<p><a href=\"leetcode\"><strong>【目录】</strong></a> | <a href=\"https://leetcode.cn/problems/linked-list-cycle-ii/\" target=\"_blank\">力扣链接</a> | <a href=\"https://leetcode.cn/problems/linked-list-cycle-ii/solution/by-taisui-3yrk/\" target=\"_blank\">力扣题解链接</a></p>\n<h1 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h1>\n<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始）</strong>。如果 pos 是 -1，则在该链表中没有环。<strong>注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</strong></p>\n<p><strong>不允许修改</strong> 链表。</p>\n<p>示例 1：</p>\n<p><img src=\"C:/Files/markdown-images/202301291146335.png\" alt=\"img\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [3,2,0,-4], pos = 1</span><br><span class=\"line\">输出：返回索引为 1 的链表节点</span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<p><img src=\"C:/Files/markdown-images/202301291146827.png\" alt=\"img\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2], pos = 0</span><br><span class=\"line\">输出：返回索引为 0 的链表节点</span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<p><img src=\"C:/Files/markdown-images/202301291146517.png\" alt=\"img\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1], pos = -1</span><br><span class=\"line\">输出：返回 null</span><br><span class=\"line\">解释：链表中没有环。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>链表中节点的数目范围在范围 [0, 104] 内</li>\n<li>-105 &lt;= Node.val &lt;= 105</li>\n<li>pos 的值为 -1 或者链表中的一个有效索引</li>\n</ul>\n<p>进阶：你是否可以使用 O(1) 空间解决此题？</p>\n<h1 id=\"题解\">题解<a title=\"#题解\" href=\"#题解\"></a></h1>\n<h3 id=\"解题思路\">解题思路<a title=\"#解题思路\" href=\"#解题思路\"></a></h3>\n<ul>\n<li>这道题主要考查两点：\n<ol>\n<li>判断链表是否有环（也即 <a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\" target=\"_blank\">141.环形链表</a>）</li>\n<li>若链表有环，怎么找到环的入口</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"判断链表是否有环\">判断链表是否有环<a title=\"#判断链表是否有环\" href=\"#判断链表是否有环\"></a></h4>\n<ul>\n<li>使用快慢指针，让 fast 和 slow 都从头结点出发，fast 每次移动两步，slow 每次移动一步，若两个指针相遇，则说明链表有环。</li>\n</ul>\n<h4 id=\"若链表有环，怎么找到环的入口\">若链表有环，怎么找到环的入口<a title=\"#若链表有环，怎么找到环的入口\" href=\"#若链表有环，怎么找到环的入口\"></a></h4>\n<ul>\n<li>当快慢指针相遇时，「头结点到入环结点的距离」就等于若干倍的「相遇结点到入环结点的距离（顺着链表方向）」。这意味着什么呢？这就意味着若两个指针同时从头结点和相遇结点出发，每次都移动一步，那么它们最终会在入环结点处相遇。(具体看下面推导过程)</li>\n</ul>\n<h4 id=\"推导证明\">推导证明<a title=\"#推导证明\" href=\"#推导证明\"></a></h4>\n<ol>\n<li>\n<p>首先要明确，若相遇则一定是在环内，这个没什么好说的。</p>\n<ul>\n<li>\n<p>当 slow 入环后，对 slow 来说，fast 是在追赶它，而且每次都会靠近一个节点，因此一定可以追到。</p>\n</li>\n<li>\n<p>由于 slow  每次只走一步，且 fast 每次都会追到一步，而 fast 距离 slow（相对 fast 追 slow 来说，fast 在 slow 之后）最多不会超过环的所有结点数，因此 fast 一定会在 slow 走完环的一圈之前追到 slow。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>再来看看寻找环的入口的过程（这里找张纸对着画一画会很清晰，需要计算，但是很简单）</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>若链表有环，那么链表可以分为三个部分（顺着链表方向）：</p>\n<ol>\n<li>头结点到入环结点的部分，记此部分距离为 a；</li>\n<li>入环结点到相遇节点的部分，记此部分距离为 b；</li>\n<li>相遇部分到入环结点的部分，记此部分距离为 c。</li>\n</ol>\n</li>\n<li>\n<p>fast 走过的距离为 <code>len1 = a + b + n * (b + c)</code>（n 为 fast 在环内走了 n 圈才遇到 slow ）</p>\n</li>\n<li>\n<p>slow 走过的距离为 <code>len2 = a + b</code>（前面说过，一定是在 slow 走完环的一圈之前相遇，所以 slow 走过的距离不是 <code>len2 = a + n * (b + c) + b</code>）。</p>\n</li>\n<li>\n<p>又因为 fast 每次走两步，slow 每次走一步，所以 fast 走过的距离等于二倍的 slow 走过的距离：<code>len1 = 2 * len2</code>。</p>\n</li>\n<li>\n<p>联立以上三式可得：<code>a + b + n * (b + c) = 2 * (a + b)</code>。</p>\n</li>\n<li>\n<p>化简整理后可得：<code>a = (n - 1) * (b + c) + c</code>（由于要求 a，所以整理成其他变量和 a 的关系的形式）。</p>\n</li>\n<li>\n<p>这个式子说明：若两个指针同时从头结点和相遇结点出发，每次都移动一步，那么它们最终会在入环结点处相遇，此时从相遇结点出发的指针共在环里循环了 n-1 圈。</p>\n</li>\n</ul>\n<h3 id=\"代码\">代码<a title=\"#代码\" href=\"#代码\"></a></h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> ListNode *<span class=\"title function_\">detectCycle</span><span class=\"params\">(<span class=\"keyword\">struct</span> ListNode *head)</span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">fast</span> =</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">slow</span> =</span> head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class=\"line\">        fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        slow = slow-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fast == slow) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (fast != head) &#123;</span><br><span class=\"line\">                fast = fast-&gt;next;</span><br><span class=\"line\">                head = head-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fast;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h3>\n<p>时间复杂度：O(n)​</p>\n<p>空间复杂度：O(1)​</p>\n<h1 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h1>\n<p>有点印象，知道判断有没有环用快慢指针，然后快指针每次走两步，慢指针每次走一步。寻找环的入口这里，依稀记得要计算，但是不知道要怎么算。看了题解之后也没写出来，又看了代码才写了出来。</p>\n<p>总的来说，做出来之后感觉这道题也不难，但是自己就是做不出来，还是水平太低。</p>\n","link":"leetcode/142-环形链表II","comments":true,"plink":"https://hs-zhangsan.github.io/leetcode/142-环形链表II/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"题解","title":"题解","index":"2"},{"id":"总结","title":"总结","index":"3"}],"reward":true,"copyright":{"published":"January 29, 2023","updated":"March 31, 2023","author":"zhangsan","link":"<a href=\"https://hs-zhangsan.github.io/leetcode/142-环形链表II/\" title=\"142-环形链表II\">https://hs-zhangsan.github.io/leetcode/142-环形链表II/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}
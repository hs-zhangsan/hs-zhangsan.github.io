{"title":"206-反转链表","date":"2023-01-25T19:07:34.000Z","date_formatted":{"ll":"Jan 25, 2023","L":"01/25/2023","MM-DD":"01-25"},"updated":"2023-03-31T11:45:37.368Z","content":"<p><a href=\"leetcode\"><strong>【目录】</strong></a> | <a href=\"https://leetcode.cn/problems/reverse-linked-list/\" target=\"_blank\">力扣链接</a> | <a href=\"https://leetcode.cn/problems/reverse-linked-list/solution/by-taisui-95fh/\" target=\"_blank\">力扣题解链接</a></p>\n<h1 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h1>\n<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>\n<p>示例 1：</p>\n<p><img src=\"C:/Files/markdown-images/202301251909964.jpeg\" alt=\"img\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2,3,4,5]</span><br><span class=\"line\">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\" alt=\"img\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2]</span><br><span class=\"line\">输出：[2,1]</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>链表中节点的数目范围是 [0, 5000]</li>\n<li>-5000 &lt;= Node.val &lt;= 5000</li>\n</ul>\n<p>进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>\n<h1 id=\"题解\">题解<a title=\"#题解\" href=\"#题解\"></a></h1>\n<h3 id=\"方法一：双指针法\">方法一：双指针法<a title=\"#方法一：双指针法\" href=\"#方法一：双指针法\"></a></h3>\n<ul>\n<li>反转链表比较简单，很容易想到，从前向后遍历链表，然后把每个结点的 next 指向前一个结点就好。</li>\n<li>具体实现中，首先需要两个指针，一个 curr 指针在遍历到每个结点进行操作，一个 prew 指针指向 curr 的前一个结点。其次，由于 curr-&gt;next 指向 prew，导致原来的 curr 的下一个结点失去引用，所以还需要一个指针 temp 用来保存后一个结点。</li>\n</ul>\n<h3 id=\"代码\">代码<a title=\"#代码\" href=\"#代码\"></a></h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//双指针法</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> ListNode* <span class=\"title function_\">reverseList</span><span class=\"params\">(<span class=\"keyword\">struct</span> ListNode* head)</span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">curr</span> =</span> head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">prew</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//保存下一个结点</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">temp</span> =</span> curr-&gt;next;</span><br><span class=\"line\">        <span class=\"comment\">//反转结点</span></span><br><span class=\"line\">        curr-&gt;next = prew;</span><br><span class=\"line\">        <span class=\"comment\">//更新 curr 和 prew 指针</span></span><br><span class=\"line\">        prew = curr;</span><br><span class=\"line\">        curr = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prew;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二：递归法\">方法二：递归法<a title=\"#方法二：递归法\" href=\"#方法二：递归法\"></a></h3>\n<ul>\n<li>递归法和双指针法是一样的逻辑，同样是当 curr 为空的时候循环结束，不断将 curr 指向 pre 的过程。具体可以对比双指针法和下面的代码，代码已经详细注释，理解起来应该相当容易。</li>\n</ul>\n<h3 id=\"代码-1\">代码<a title=\"#代码-1\" href=\"#代码-1\"></a></h3>\n<p>从前向后反转指针指向</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//递归法（从前向后反转指针指向）</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> ListNode* <span class=\"title function_\">reverse</span><span class=\"params\">(<span class=\"keyword\">struct</span> ListNode* curr, <span class=\"keyword\">struct</span> ListNode* prew)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!curr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prew;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">temp</span> =</span> curr-&gt;next;</span><br><span class=\"line\">    curr-&gt;next = prew;</span><br><span class=\"line\">    <span class=\"comment\">//可以与双指针法对比，其实逻辑是一样的，只是用递归实现而已</span></span><br><span class=\"line\">    <span class=\"comment\">//下面的代码省去了双指针中更新 curr 和 prew 的过程，直接在递归中引用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> reverse(temp, curr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> ListNode* <span class=\"title function_\">reverseList</span><span class=\"params\">(<span class=\"keyword\">struct</span> ListNode* head)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这里也是省去了初始化 curr 和 prew 的过程，直接在递归中引用</span></span><br><span class=\"line\">    <span class=\"comment\">//下面正文中的代码和注释中的代码是等价的</span></span><br><span class=\"line\">    <span class=\"comment\">//struct ListNode* curr = head;</span></span><br><span class=\"line\">    <span class=\"comment\">//struct ListNode* prew = NULL;</span></span><br><span class=\"line\">    <span class=\"comment\">//return reverse(curr, prew);</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> reverse(head, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这时候聪明的同学就会说了，上面的双指针法和递归法实质上都是从前往后反转指针指向，那么能不能从后往前反转指针指向呢？</li>\n<li>答案是当然能了，具体代码如下，已经详细注释。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//递归法（从后向前反转指针指向）</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> ListNode* <span class=\"title function_\">reverseList</span><span class=\"params\">(<span class=\"keyword\">struct</span> ListNode* head)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//递归结束条件判断</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!head || !head-&gt;next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//调用递归，反转第二个结点后的结点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">newHead</span> =</span> reverseList(head-&gt;next);</span><br><span class=\"line\">    <span class=\"comment\">//反转头结点与第二个结点</span></span><br><span class=\"line\">    head-&gt;next-&gt;next = head;</span><br><span class=\"line\">    <span class=\"comment\">//此时 head 是尾结点，尾结点需要指向 NULL</span></span><br><span class=\"line\">    head-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> newHead;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>写题解不易，若对你有帮助，点赞评论再走吧。(～￣▽￣)～</p>\n<h1 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h1>\n<p>看了一眼题解直接秒了，用的双指针，递归没做，看了一下之前的题解脑子里过了一遍。</p>\n","link":"leetcode/206-反转链表","comments":true,"plink":"https://hs-zhangsan.github.io/leetcode/206-反转链表/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"题解","title":"题解","index":"2"},{"id":"总结","title":"总结","index":"3"}],"reward":true,"copyright":{"published":"January 25, 2023","updated":"March 31, 2023","author":"zhangsan","link":"<a href=\"https://hs-zhangsan.github.io/leetcode/206-反转链表/\" title=\"206-反转链表\">https://hs-zhangsan.github.io/leetcode/206-反转链表/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}
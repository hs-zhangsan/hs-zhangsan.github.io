{"title":"数组理论基础","date":"2023-01-18T09:59:35.000Z","date_formatted":{"ll":"Jan 18, 2023","L":"01/18/2023","MM-DD":"01-18"},"updated":"2023-03-31T11:45:37.377Z","content":"<p><a href=\"leetcode\"><strong>【目录】</strong></a></p>\n<p>数组比较简单，没什么好说的，为了系统一点也写上，这里直接把 Carl 的搬运过来了，原文链接 <a href=\"https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html\" target=\"_blank\">https://programmercarl.com/数组理论基础.html</a></p>\n<hr>\n<p>数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力</p>\n<p>也就是说，想法很简单，但实现起来 可能就不是那么回事了。</p>\n<p>首先要知道数组在内存中的存储方式，这样才能真正理解数组相关的面试题</p>\n<p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p>\n<p>数组可以方便的通过下标索引的方式获取到下标下对应的数据。</p>\n<p>举一个字符数组的例子，如图所示：</p>\n<p><img src=\"C:/Files/markdown-images/202301181011627.png\" alt=\"算法通关数组\" loading=\"lazy\" class=\"φbp\"></p>\n<p>需要两点注意的是</p>\n<ul>\n<li><strong>数组下标都是从0开始的。</strong></li>\n<li><strong>数组内存空间的地址是连续的</strong></li>\n</ul>\n<p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p>\n<p>例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：</p>\n<p><img src=\"C:/Files/markdown-images/202301181011652.png\" alt=\"算法通关数组1\" loading=\"lazy\" class=\"φbp\"></p>\n<p>而且大家如果使用C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。</p>\n<p><strong>数组的元素是不能删的，只能覆盖。</strong></p>\n<p>那么二维数组直接上图，大家应该就知道怎么回事了</p>\n<p><img src=\"C:/Files/markdown-images/202301181011662.png\" alt=\"算法通关数组2\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>那么二维数组在内存的空间地址是连续的么？</strong></p>\n<p>不同编程语言的内存管理是不一样的，以C++为例，在C++中二维数组是连续分布的。</p>\n<p>我们来做一个实验，C++测试代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test_arr</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> array[<span class=\"number\">2</span>][<span class=\"number\">3</span>] = &#123;</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    cout &lt;&lt; &amp;array[<span class=\"number\">0</span>][<span class=\"number\">0</span>] &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; &amp;array[<span class=\"number\">0</span>][<span class=\"number\">1</span>] &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; &amp;array[<span class=\"number\">0</span>][<span class=\"number\">2</span>] &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &amp;array[<span class=\"number\">1</span>][<span class=\"number\">0</span>] &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; &amp;array[<span class=\"number\">1</span>][<span class=\"number\">1</span>] &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; &amp;array[<span class=\"number\">1</span>][<span class=\"number\">2</span>] &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">test_arr</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试地址为</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x7ffee4065820 0x7ffee4065824 0x7ffee4065828</span><br><span class=\"line\">0x7ffee406582c 0x7ffee4065830 0x7ffee4065834</span><br></pre></td></tr></table></figure>\n<p>注意地址为16进制，可以看出二维数组地址是连续一条线的。</p>\n<p>一些录友可能看不懂内存地址，我就简单介绍一下， 0x7ffee4065820 与 0x7ffee4065824 差了一个4，就是4个字节，因为这是一个int型的数组，所以两个相邻数组元素地址差4个字节。</p>\n<p>0x7ffee4065828 与 0x7ffee406582c 也是差了4个字节，在16进制里8 + 4 = c，c就是12。</p>\n<p>如图：</p>\n<p><img src=\"C:/Files/markdown-images/202301181011673.png\" alt=\"数组内存\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>所以可以看出在C++中二维数组在地址空间上是连续的</strong>。</p>\n<p>像Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。</p>\n<p>所以看不到每个元素的地址情况，这里我以Java为例，也做一个实验。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test_arr</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[][] arr = &#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;, &#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;, &#123;<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>&#125;, &#123;<span class=\"number\">9</span>,<span class=\"number\">9</span>,<span class=\"number\">9</span>&#125;&#125;;</span><br><span class=\"line\">    System.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    System.out.println(arr[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    System.out.println(arr[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    System.out.println(arr[<span class=\"number\">3</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出的地址为：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[I@7852e922</span><br><span class=\"line\">[I@4e25154f</span><br><span class=\"line\">[I@70dea4e</span><br><span class=\"line\">[I@5c647e05</span><br></pre></td></tr></table></figure>\n<p>这里的数值也是16进制，这不是真正的地址，而是经过处理过后的数值了，我们也可以看出，二维数组的每一行头结点的地址是没有规则的，更谈不上连续。</p>\n<p>所以Java的二维数组可能是如下排列的方式：</p>\n<p><img src=\"C:/Files/markdown-images/202301181011706.png\" alt=\"算法通关数组3\" loading=\"lazy\" class=\"φbp\"></p>\n<p>这里面试中数组相关的理论知识就介绍完了。</p>\n","link":"leetcode/数组理论基础","comments":true,"plink":"https://hs-zhangsan.github.io/leetcode/数组理论基础/","reward":true,"copyright":{"published":"January 18, 2023","updated":"March 31, 2023","author":"zhangsan","link":"<a href=\"https://hs-zhangsan.github.io/leetcode/数组理论基础/\" title=\"数组理论基础\">https://hs-zhangsan.github.io/leetcode/数组理论基础/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}
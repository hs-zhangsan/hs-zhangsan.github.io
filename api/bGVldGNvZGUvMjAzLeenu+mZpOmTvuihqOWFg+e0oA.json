{"title":"203-移除链表元素","date":"2023-01-23T10:06:07.000Z","date_formatted":{"ll":"Jan 23, 2023","L":"01/23/2023","MM-DD":"01-23"},"updated":"2023-03-31T11:45:37.368Z","content":"<p><a href=\"leetcode\"><strong>【目录】</strong></a> | <a href=\"https://leetcode.cn/problems/remove-linked-list-elements/\" target=\"_blank\">力扣链接</a> | <a href=\"https://leetcode.cn/problems/remove-linked-list-elements/solution/by-taisui-lx4j/\" target=\"_blank\">力扣题解链接</a></p>\n<h1 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h1>\n<p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p>\n<p>示例 1：</p>\n<p><img src=\"C:/Files/markdown-images/202301231012371.jpeg\" alt=\"img\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class=\"line\">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [], val = 1</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [7,7,7,7], val = 7</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>列表中的节点数目在范围 [0, 104] 内</li>\n<li>1 &lt;= Node.val &lt;= 50</li>\n<li>0 &lt;= val &lt;= 50</li>\n</ul>\n<h1 id=\"题解\">题解<a title=\"#题解\" href=\"#题解\"></a></h1>\n<h3 id=\"解题思路\">解题思路<a title=\"#解题思路\" href=\"#解题思路\"></a></h3>\n<ul>\n<li>链表的增删操作比较简单，\n<ul>\n<li>删除某个结点只需要将其前一个结点的 next 指向其后一个结点即可。<strong>如果使用 c/c++ 千万记得释放内存！</strong></li>\n<li>在某两个结点之间增加新的结点只需将前一个结点的 next 指向要增加的结点，然后将新增加结点的 next 指向后一个结点即可。</li>\n</ul>\n</li>\n<li>另外，<strong>在遇到链表类题目时，都可以无脑用哑结点</strong>。所谓哑结点，即设置一个虚拟头结点（哑结点），让哑结点 dummyHead 的 next 指向原头结点，这样原链表的所有节点就都可以按照统一的方式进行移除了。最后在 return 的时候记得 <code>return dummyHead-&gt;next</code>。哑结点的好处可以参考卡子哥的这篇文章：<a href=\"https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html\" target=\"_blank\">链表：听说用虚拟头节点会方便很多？</a>，这里不再赘述。</li>\n<li>最后，如果使用 c/c++ 移除链表结点，<strong>一定记得清理内存</strong>，哪怕在力扣中没有手动在内存中删除这个结点，依然也是可以通过的。其他语言例如Java、Python，都有自己的内存回收机制，就不用自己手动释放了。</li>\n</ul>\n<h3 id=\"代码\">代码<a title=\"#代码\" href=\"#代码\"></a></h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     struct ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> ListNode* <span class=\"title function_\">removeElements</span><span class=\"params\">(<span class=\"keyword\">struct</span> ListNode* head, <span class=\"type\">int</span> val)</span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">dummyHead</span> =</span> <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> ListNode));</span><br><span class=\"line\">    dummyHead-&gt;next = head;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">curr</span> =</span> dummyHead;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (curr-&gt;next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (curr-&gt;next-&gt;val == val) &#123;</span><br><span class=\"line\">            <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">temp</span> =</span> curr-&gt;next;</span><br><span class=\"line\">            curr-&gt;next = curr-&gt;next-&gt;next;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(temp); <span class=\"comment\">//释放已删除的结点</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            curr = curr-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummyHead-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h3>\n<p>时间复杂度：O(n)</p>\n<p>空间复杂度：O(1)​</p>\n<ul>\n<li><strong>注意，链表的增删实际上都是 O(1) 操作，但是操作时需要先从头结点查找到要操作的结点，查找的时间复杂度是 O(n)。</strong></li>\n</ul>\n<h1 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h1>\n<p>删除链表节点很基础，能知道逻辑，但是写出来还是磕磕碰碰的。乌鱼子━━(￣ー￣*|||━━</p>\n","link":"leetcode/203-移除链表元素","comments":true,"plink":"https://hs-zhangsan.github.io/leetcode/203-移除链表元素/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"题解","title":"题解","index":"2"},{"id":"总结","title":"总结","index":"3"}],"reward":true,"copyright":{"published":"January 23, 2023","updated":"March 31, 2023","author":"zhangsan","link":"<a href=\"https://hs-zhangsan.github.io/leetcode/203-移除链表元素/\" title=\"203-移除链表元素\">https://hs-zhangsan.github.io/leetcode/203-移除链表元素/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}
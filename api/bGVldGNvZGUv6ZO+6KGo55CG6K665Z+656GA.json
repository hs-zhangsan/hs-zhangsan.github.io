{"title":"链表理论基础","date":"2023-01-23T10:06:36.000Z","date_formatted":{"ll":"Jan 23, 2023","L":"01/23/2023","MM-DD":"01-23"},"updated":"2023-03-31T11:45:37.378Z","content":"<p><a href=\"leetcode\"><strong>【目录】</strong></a></p>\n<p>原链接 <a href=\"https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html\" target=\"_blank\">https://programmercarl.com/链表理论基础.html</a></p>\n<hr>\n<h1 id=\"关于链表，你该了解这些！\">关于链表，你该了解这些！<a title=\"#关于链表，你该了解这些！\" href=\"#关于链表，你该了解这些！\"></a></h1>\n<p>什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p>\n<p>链表的入口节点称为链表的头结点也就是head。</p>\n<p>如图所示： <img src=\"C:/Files/markdown-images/202301231007018.png\" alt=\"链表1\" loading=\"lazy\"></p>\n<h1 id=\"链表的类型\">链表的类型<a title=\"#链表的类型\" href=\"#链表的类型\"></a></h1>\n<p>接下来说一下链表的几种类型:</p>\n<h2 id=\"单链表\">单链表<a title=\"#单链表\" href=\"#单链表\"></a></h2>\n<p>刚刚说的就是单链表。</p>\n<h2 id=\"双链表\">双链表<a title=\"#双链表\" href=\"#双链表\"></a></h2>\n<p>单链表中的指针域只能指向节点的下一个节点。</p>\n<p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p>\n<p>双链表 既可以向前查询也可以向后查询。</p>\n<p>如图所示： <img src=\"C:/Files/markdown-images/202301231007048.png\" alt=\"链表2\" loading=\"lazy\"></p>\n<h2 id=\"循环链表\">循环链表<a title=\"#循环链表\" href=\"#循环链表\"></a></h2>\n<p>循环链表，顾名思义，就是链表首尾相连。</p>\n<p>循环链表可以用来解决约瑟夫环问题。</p>\n<p><img src=\"C:/Files/markdown-images/202301231007064.png\" alt=\"链表4\" loading=\"lazy\" class=\"φbp\"></p>\n<h1 id=\"链表的存储方式\">链表的存储方式<a title=\"#链表的存储方式\" href=\"#链表的存储方式\"></a></h1>\n<p>了解完链表的类型，再来说一说链表在内存中的存储方式。</p>\n<p>数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。</p>\n<p>链表是通过指针域的指针链接在内存中各个节点。</p>\n<p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p>\n<p>如图所示：</p>\n<p><img src=\"C:/Files/markdown-images/202301231007056.png\" alt=\"链表3\" loading=\"lazy\" class=\"φbp\"></p>\n<p>这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。</p>\n<h1 id=\"链表的定义\">链表的定义<a title=\"#链表的定义\" href=\"#链表的定义\"></a></h1>\n<p>接下来说一说链表的定义。</p>\n<p>链表节点的定义，很多同学在面试的时候都写不好。</p>\n<p>这是因为平时在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。</p>\n<p>而在面试的时候，一旦要自己手写链表，就写的错漏百出。</p>\n<p>这里我给出C/C++的定义链表节点方式，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 单链表</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;  <span class=\"comment\">// 节点上存储的元素</span></span><br><span class=\"line\">    ListNode *next;  <span class=\"comment\">// 指向下一个节点的指针</span></span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">next</span>(<span class=\"literal\">NULL</span>) &#123;&#125;  <span class=\"comment\">// 节点的构造函数</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>有同学说了，我不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。</p>\n<p>但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：</p>\n<p>通过自己定义构造函数初始化节点：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListNode* head = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n<p>使用默认构造函数初始化节点：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListNode* head = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>();</span><br><span class=\"line\">head-&gt;val = <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n<p>所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</p>\n<h1 id=\"链表的操作\">链表的操作<a title=\"#链表的操作\" href=\"#链表的操作\"></a></h1>\n<h2 id=\"删除节点\">删除节点<a title=\"#删除节点\" href=\"#删除节点\"></a></h2>\n<p>删除D节点，如图所示：</p>\n<p><img src=\"C:/Files/markdown-images/202301231007062.png\" alt=\"链表-删除节点\" loading=\"lazy\" class=\"φbp\"></p>\n<p>只要将C节点的next指针 指向E节点就可以了。</p>\n<p>那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。</p>\n<p>是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存。</p>\n<p>其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。</p>\n<h2 id=\"添加节点\">添加节点<a title=\"#添加节点\" href=\"#添加节点\"></a></h2>\n<p>如图所示：</p>\n<p><img src=\"C:/Files/markdown-images/202301231007067.png\" alt=\"链表-添加节点\" loading=\"lazy\" class=\"φbp\"></p>\n<p>可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。</p>\n<p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p>\n<h1 id=\"性能分析\">性能分析<a title=\"#性能分析\" href=\"#性能分析\"></a></h1>\n<p>再把链表的特性和数组的特性进行一个对比，如图所示：</p>\n<p><img src=\"C:/Files/markdown-images/202301231007136.png\" alt=\"链表-链表与数据性能对比\" loading=\"lazy\" class=\"φbp\"></p>\n<p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p>\n<p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p>\n<p>相信大家已经对链表足够的了解，后面我会讲解关于链表的高频面试题目，我们下期见！</p>\n","link":"leetcode/链表理论基础","comments":true,"plink":"https://hs-zhangsan.github.io/leetcode/链表理论基础/","toc":[{"id":"关于链表，你该了解这些！","title":"关于链表，你该了解这些！","index":"1"},{"id":"链表的类型","title":"链表的类型","index":"2","children":[{"id":"单链表","title":"单链表","index":"2.1"},{"id":"双链表","title":"双链表","index":"2.2"},{"id":"循环链表","title":"循环链表","index":"2.3"}]},{"id":"链表的存储方式","title":"链表的存储方式","index":"3"},{"id":"链表的定义","title":"链表的定义","index":"4"},{"id":"链表的操作","title":"链表的操作","index":"5","children":[{"id":"删除节点","title":"删除节点","index":"5.1"},{"id":"添加节点","title":"添加节点","index":"5.2"}]},{"id":"性能分析","title":"性能分析","index":"6"}],"reward":true,"copyright":{"published":"January 23, 2023","updated":"March 31, 2023","author":"zhangsan","link":"<a href=\"https://hs-zhangsan.github.io/leetcode/链表理论基础/\" title=\"链表理论基础\">https://hs-zhangsan.github.io/leetcode/链表理论基础/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}
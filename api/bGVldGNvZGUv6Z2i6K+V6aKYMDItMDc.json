{"title":"面试题02.07","date":"2023-01-28T11:01:22.000Z","date_formatted":{"ll":"Jan 28, 2023","L":"01/28/2023","MM-DD":"01-28"},"updated":"2023-03-31T11:45:37.379Z","content":"<p><a href=\"leetcode\"><strong>【目录】</strong></a> | <a href=\"https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/\" target=\"_blank\">力扣链接</a> | <a href=\"https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/solution/by-taisui-x9fc/\" target=\"_blank\">力扣题解链接</a></p>\n<h1 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h1>\n<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>\n<p>图示两个链表在节点 c1 开始相交：</p>\n<p><img src=\"C:/Files/markdown-images/202301281104852.png\" alt=\"img\" loading=\"lazy\" class=\"φbp\"></p>\n<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>\n<p><strong>注意</strong>，函数返回结果后，链表必须 保持其原始结构 。</p>\n<p>示例 1：</p>\n<p><img src=\"C:/Files/markdown-images/202301281104133.png\" alt=\"img\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class=\"line\">输出：Intersected at &#x27;8&#x27;</span><br><span class=\"line\">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class=\"line\">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class=\"line\">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<p><img src=\"C:/Files/markdown-images/202301281105235.png\" alt=\"img\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class=\"line\">输出：Intersected at &#x27;2&#x27;</span><br><span class=\"line\">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class=\"line\">从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class=\"line\">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<p><img src=\"C:/Files/markdown-images/202301281105800.png\" alt=\"img\" loading=\"lazy\" class=\"φbp\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class=\"line\">输出：null</span><br><span class=\"line\">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class=\"line\">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class=\"line\">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>listA 中节点数目为 m</li>\n<li>listB 中节点数目为 n</li>\n<li>0 &lt;= m, n &lt;= 3 * 104</li>\n<li>1 &lt;= Node.val &lt;= 105</li>\n<li>0 &lt;= skipA &lt;= m</li>\n<li>0 &lt;= skipB &lt;= n</li>\n<li>如果 listA 和 listB 没有交点，intersectVal 为 0</li>\n<li>如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]</li>\n</ul>\n<p>进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？</p>\n<h1 id=\"题解\">题解<a title=\"#题解\" href=\"#题解\"></a></h1>\n<h3 id=\"解题思路\">解题思路<a title=\"#解题思路\" href=\"#解题思路\"></a></h3>\n<ul>\n<li>\n<p>首先要注意，判断链表是否相交是看指针是否相等而不是数值是否相等。</p>\n</li>\n<li>\n<p>先分别计算出两个链表的长度并计算长度差 diff，之后让较长的链表向前移动 diff 步，这样两个链表就实现了尾部对齐（即操作两个链表的指针在同一起点上）。最后遍历两个数组判断是否有交点。</p>\n</li>\n<li>\n<p>思路比较简单，具体代码如下（已详细注释）。</p>\n</li>\n</ul>\n<h3 id=\"代码\">代码<a title=\"#代码\" href=\"#代码\"></a></h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> ListNode *<span class=\"title function_\">getIntersectionNode</span><span class=\"params\">(<span class=\"keyword\">struct</span> ListNode *headA, <span class=\"keyword\">struct</span> ListNode *headB)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//使用两个指针分别统计两个来链表的长度</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">currA</span> =</span> headA;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">currB</span> =</span> headB;</span><br><span class=\"line\">    <span class=\"type\">int</span> countA = <span class=\"number\">0</span>, countB = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (currA) &#123;</span><br><span class=\"line\">        countA++;</span><br><span class=\"line\">        currA = currA-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (currB) &#123;</span><br><span class=\"line\">        countB++;</span><br><span class=\"line\">        currB = currB-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//让 headA 指向较长的链表，便于后续操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (countB &gt; countA) &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ListNode</span>* <span class=\"title\">temp</span> =</span> headA;</span><br><span class=\"line\">        headA = headB;</span><br><span class=\"line\">        headB = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//计算两个链表的长度差</span></span><br><span class=\"line\">    <span class=\"type\">int</span> diff = countA &gt; countB ? countA - countB : countB - countA;</span><br><span class=\"line\">    <span class=\"comment\">//让两个链表尾部对其</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (diff--) &#123;</span><br><span class=\"line\">        headA = headA-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//遍历两个来链表，若遇到相同说明相交，返回相交结点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (headA) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (headA == headB) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> headA;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        headA = headA-&gt;next;</span><br><span class=\"line\">        headB = headB-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//若无相交则返回空指针</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h3>\n<p>时间复杂度：O(n+m)​</p>\n<p>空间复杂度：O(1)</p>\n<h1 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h1>\n<p>一眼没看出来，看了题解发现和之前是一样的问题，被图给误导了，要把它看成单独的两条链表，然后有了思路就很简单了，也直接做了出来，看了一下之前写的题解，基本写法都一样，有一点小细节具体处理不同，不影响，直接用之前的题解了。</p>\n","link":"leetcode/面试题02-07","comments":true,"plink":"https://hs-zhangsan.github.io/leetcode/面试题02-07/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"题解","title":"题解","index":"2"},{"id":"总结","title":"总结","index":"3"}],"reward":true,"copyright":{"published":"January 28, 2023","updated":"March 31, 2023","author":"zhangsan","link":"<a href=\"https://hs-zhangsan.github.io/leetcode/面试题02-07/\" title=\"面试题02.07\">https://hs-zhangsan.github.io/leetcode/面试题02-07/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}
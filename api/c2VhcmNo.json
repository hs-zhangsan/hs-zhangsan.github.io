[{"title":"CentOS7开放端口及查看端口开放","date":"2023-04-08T21:35:49.000Z","date_formatted":{"ll":"Apr 8, 2023","L":"04/08/2023","MM-DD":"04-08"},"updated":"2023-04-08T22:19:02.635Z","content":"防火墙\n查看防火墙状态\n1firewall-cmd --state\n打开防火墙\n1systemctl start firewalld.service\n关闭防火墙（如果要开放的端口太多，嫌麻烦，可以关闭防火墙）\n1systemctl stop firewalld.service\n重启防火墙\n1systemctl restart firewalld.service\n端口\n查看防火墙所有开放的端口\n1firewall-cmd --zone=public --list-ports\n查看监听的端口\n12netstat -ntlp\t#监听TCP端口netstat -nulp\t#监听UDP端口\n开放端口（注意更改协议和端口号就行）\n123firewall-cmd --zone=public --add-port=80/tcp --permanent\t#开放TCP80端口firewall-cmd --zone=public --add-port=8090/tcp --permanent\t#开放TCP8090端口firewall-cmd --zone=public --add-port=9595/udp --permanent\t#开放UDP9595端口\n关闭端口（还是一样，更改协议和端口号就行）\n123firewall-cmd --zone=public --remove-port=80/tcp --permanent\t\t#关闭TCP80端口firewall-cmd --zone=public --remove-port=8090/tcp --permanent\t#关闭TCP8090端口firewall-cmd --zone=public --remove-port=9595/udp--permanent\t#关闭UDP9595端口\n配置生效\n1firewall-cmd --reload   #配置立即生效","plink":"https://hs-zhangsan.github.io/posts/centos&firewalld/"},{"title":"Hugo & GithubPages.md","date":"2023-04-08T19:54:12.000Z","date_formatted":{"ll":"Apr 8, 2023","L":"04/08/2023","MM-DD":"04-08"},"updated":"2023-04-11T12:04:18.141Z","content":"Hugo &amp; CentOS 建站教程\n0、步骤\n1、安装Git\n2、安装Go\n3、安装Hugo\n4、用Hugo建站\n1、安装Git\n\n通过运行以下命令更新系统包列表：\n\n1sudo yum update\n\n通过运行以下命令安装版本控制系统 Git：\n\n1sudo yum install git\n\n通过运行以下命令查看 Git 版本，正常输出则说明安装成功：\n\n1git --version\n2、安装Go\n\n从GO语言官方网站下载对应的二进制存档包：\n\n1sudo wget https://dl.google.com/go/go1.20.3.linux-amd64.tar.gz\n\n下载后将其解压缩到 /usr/local，将自动在其中创建一个Go树 /usr/local/go\n\n1tar -C /usr/local -xzf go1.20.3.linux-amd64.tar.gz\n\n配置GO语言系统环境变量：\n\n通过运行以下命令编辑profile文件：通过运行以下命令编辑profile文件：\n1vim /etc/profile \n【i】进入编辑模式，在文件最后添加如下内容 ：\n1234#go settingexport GOROOT=/usr/local/goexport GOPATH=/usr/local/gopathexport PATH=$PATH:$GOROOT/bin\n【Esc】退出编辑模式，再输入 “:wq” 保存并退出。\n然后通过运行以下命令使 profile 文件现在生效：\n1source /etc/profile\n\n通过运行以下命令查看 Go 版本，正常输出则说明安装成功：\n\n1go version\n3、安装Hugo\n\n通过运行以下命令添加 epel repo：\n\n1vim /etc/yum.repos.d/hugo.repo\n上面的命令会在 /etc/yum.repos.d/ 目录下创建一个名为 hugo.repo 的文件。\n再将下面的内容复制进去：\n123456789[daftaupe-hugo]name=Copr repo for hugo owned by daftaupebaseurl=https://copr-be.cloud.fedoraproject.org/results/daftaupe/hugo/epel-7-$basearch/type=rpm-mdskip_if_unavailable=Truegpgcheck=1gpgkey=https://copr-be.cloud.fedoraproject.org/results/daftaupe/hugo/pubkey.gpgrepo_gpgcheck=0enabled=1\n然后【Esc】退出编辑模式，输入 “:wq” 保存并退出。\n\n通过运行以下命令安装 hugo：\n\n1sudo yum -y install hugo\n\n通过运行以下命令查看 Hugo 版本，正常输出则说明安装成功：\n\n1hugo version\n4、用Hugo建站\n\n生成站点\n\n使用Hugo快速生成站点，比如希望生成到 /path/to/site 路径：\n1hugo new site /path/to/site\n这样就在 /path/to/site 目录里生成了初始站点，进去目录：\n1cd /path/to/site\n站点目录结构：\n12345▸ archetypes/▸ content/▸ layouts/▸ static/  config.toml\n\n创建文章\n\n创建一个 about 页面：\n1hugo new about.md\nabout.md 自动生成到了 content/about.md 目录下，用 VIM 打开 about.md：\n1234567---title: &quot;About&quot;date: 2023-04-08T20:35:30+08:00draft: true---[正文内容]\n正文内容是 Markdown 格式的，--- 之间的内容是文章的标题、日期、封面等信息，可以自定义增加或者删除。\n创建第一篇文章，放到 post 目录，方便之后生成聚合页面。\n1hugo new post/first.md\n打开这篇文章，随便写点什么：\n1234567---title: &quot;First&quot;date: 2023-04-08T20:41:16+08:00draft: true---# Hello Hugo!\n\n安装皮肤\n\n\n不同 Hugo 皮肤操作可能不同，以皮肤说明文档为基准。\n\n到 皮肤列表 挑选一个心仪的皮肤，比如你觉得 NeXT 皮肤不错，点击【HOMEPAGE】进入 Github 页面，然后通过运行以下命令将其克隆到 themes 目录里：\n1git clone https://github.com/leopku/hugo-theme-next.git themes/next\n\n运行Hugo\n\n站点根目录执行 Hugo 命令进行调试：\n1hugo server --theme=hyde --buildDrafts\n浏览器里打开： http://localhost:1313\n\n部署\n\n假设你需要部署在 GitHubPages 上，首先在GitHub上创建一个Repository，命名为：username.github.io （username为你的github用户名）。\n在站点根目录执行 Hugo 命令生成最终页面：\n1$ hugo --theme=hyde --baseUrl=&quot;http://username.github.io/&quot;\n（注意，以上命令并不会生成草稿页面，如果未生成任何文章，请去掉文章头部的 “draft=true” 再重新生成。）\n如果一切顺利，所有静态页面都会生成到 public 目录，将 pubilc 目录里所有文件 push 到刚创建的 Repository 的 master 分支。\n123456$ cd public$ git init$ git remote add origin https://github.com/username/username.github.io.git$ git add -A$ git commit -m &quot;first commit&quot;$ git push -u origin master\n浏览器里访问：http://username.github.io/\n","plink":"https://hs-zhangsan.github.io/posts/hugo/"},{"title":"CentOS & WordPress","date":"2023-04-06T17:50:20.000Z","date_formatted":{"ll":"Apr 6, 2023","L":"04/06/2023","MM-DD":"04-06"},"updated":"2023-04-06T17:50:22.970Z","content":"CentOS &amp; WordPress\n一、 登录云服务器\n在购买ECS服务器后，系统会创建一个ECS实例。每一个ECS实例对应一台已购买的云服务器。您可以通过电脑上自带的终端工具访问云服务器，进行应用部署和环境搭建。\n1、在ECS实例列表页面，选择实例的所属地域。\n2、找到目标实例，然后在操作列选择【更多】&gt; 【密码/密钥】 &gt; 【重置实例密码】，然后在弹出的对话框设置ECS实例的登录密码。\n\n3、 在弹出的页面，单击【立即重启】使新密码生效。\n4、在ECS实例列表页面，复制ECS实例的公网IP地址。\n5、打开电脑上的命令行终端工具。\n\nWindows：Powershell。\nMAC：Terminal。\n\nWindows用户请检查系统中是否安装有SSH工具。检查方法：\na. 在终端中输入命令ssh -V。\n1ssh -V\n如果显示SSH版本则表示已安装，如下图所示。\n\nb. 如果未安装，请下载安装OpenSSH工具。\n6、在终端中输入连接命令ssh root@[ipaddress]。\n您需要将其中的 ipaddress 替换为您的ECS服务器的公网IP地址。例如。\n1ssh root@123.123.123.123\n命令显示结果如下。\n\n7、输入yes，然后输入云服务器的登录密码。\n\n登录成功后会显示如下信息。\n\n二、部署环境\n本教程使用Apache作为后端服务器，并在云服务器上创建一个MySQL数据库用来存储数据。\n1、在ECS服务器上，执行以下命令，安装Apache服务及其扩展包。\n1yum -y install httpd httpd-manual mod_ssl mod_perl mod_auth_mysql\n返回类似如下图结果则表示安装成功。\n\n2、执行以下命令，启动Apache服务。\n1systemctl start httpd.service\n3、返回ECS控制台，在ECS实例列表页面，单击已创建的ECS实例ID链接进入ECS详情页。\n4、在左侧导航栏，单击本实例安全组，然后单击安全组的ID链接查看安全组配置。\n\n5、打开浏览器输入ECS服务器的公网IP，如果显示如下图的测试页面表示Apache服务安装成功。\n\n6、参考以下操作在ECS服务器上搭建一个MySQL数据库。\na. 执行以下命令，下载并安装MySQL。\n说明 如果网络速度较慢，下载过程可能需要10分钟。\n123wget http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpmyum -y install mysql57-community-release-el7-10.noarch.rpmyum -y install mysql-community-server --nogpgcheck\n\nb. 执行以下命令，启动MySQL数据库。\n1systemctl start mysqld.service\nc. 执行以下命令，查看MySQL运行状态。\n1systemctl status mysqld.service\nd. 执行以下命令，查看MySQL初始密码。\n1grep &quot;password&quot; /var/log/mysqld.log\n\ne. 执行以下命令，登录数据库。\n1mysql -uroot -p\nf. 执行以下命令，修改MySQL默认密码。\n说明\n\n您需要将下面命令中的NewPassWord1.修改为您要设置的数据库密码。\n新密码设置的时候如果设置的过于简单会报错，必须同时包含大小写英文字母、数字和特殊符号中的三类字符。\n注意每条完整的SQL命令结尾都有一个半角分号（;），如果多行命令中间没有分号分隔，这些命令将不会执行，直至遇到一个分号。\n\n1ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;NewPassWord1.&#x27;;\ng. 执行以下命令，创建一个存储博客网站内容的数据库。\n1create database wordpress; \nh. 执行以下命令，查看是否创建成功。\n1show databases;\ni. 输入exit退出数据库。\n\n7、WordPress是使用PHP语言开发的博客平台。参考以下操作安装PHP。\na. 执行以下命令，安装PHP。\n1yum -y install php php-mysql gd php-gd gd-devel php-xml php-common php-mbstring php-ldap php-pear php-xmlrpc php-imap\nb. 执行以下命令，创建PHP测试页面。\n1echo &quot;&lt;?php phpinfo(); ?&gt;&quot; &gt; /var/www/html/phpinfo.php\nc. 执行以下命令，重启Apache服务。\n1systemctl restart httpd\nd. 打开浏览器，访问http://&lt;ECS公网IP&gt;/phpinfo.php，显示如下页面表示PHP安装成功。\n\n三、安装和配置WordPress\n*0、安装WordPress时报错如下。\n1234567Loaded plugins: fastestmirrorLoading mirror speeds from cached hostfile * base: mirror.net.cen.ct.gov * extras: centos.mirror.constant.com * updates: us.mirrors.virtono.comNo package wordpress available.Error: Nothing to do\n解决方法：安装epel-release\n只需要从企业版Linux库配置包中安装扩展包即可。具体方法如下\n1yum install epel-release\nepel安装完成之后，再重新安装WordPress即可。\n\n完成上述环境搭建后，参考以下操作安装WordPress。\n1、执行以下命令，安装WordPress。\n1yum -y install wordpress\n显示如下信息表示安装成功。\n\n2、修改WordPress配置文件。\na. 执行以下命令，修改wp-config.php指向路径为绝对路径。\n123456# 进入/usr/share/wordpress目录。cd /usr/share/wordpress# 修改路径。ln -snf /etc/wordpress/wp-config.php wp-config.php# 查看修改后的目录结构。ll\nb. 执行以下命令，移动WordPress到Apache根目录。\n123# 在Apache的根目录/var/www/html下，创建一个wp-blog文件夹。mkdir /var/www/html/wp-blogmv * /var/www/html/wp-blog/\nc. 执行以下命令，修改wp-config.php配置文件。\n\ndatabase_name_here为之前步骤中创建的数据库名称，本示例为wordpress。\nusername_here为MySQL数据库的用户名，本示例为root。\npassword_here为MySQL数据库的登录密码，本示例为NewPassWord1.。\n\n123sed -i &#x27;s/database_name_here/wordpress/&#x27; /var/www/html/wp-blog/wp-config.phpsed -i &#x27;s/username_here/root/&#x27; /var/www/html/wp-blog/wp-config.phpsed -i &#x27;s/password_here/NewPassWord1./&#x27; /var/www/html/wp-blog/wp-config.php\nd. 执行以下命令，查看配置文件信息是否修改成功。\n1cat -n /var/www/html/wp-blog/wp-config.php\n\n3、执行以下命令，重启Apache服务。\n1systemctl restart httpd\n四、发布博客\n完成WordPress安装后，参考以下操作创建个人站点并发布内容。\n1、打开浏览器并访问http://&lt;ECS公网IP&gt;/wp-blog/wp-admin/install.php。\n2、设置您的站点名称、管理员用户名和密码，然后单击Install WordPress完成WordPress初始化。\n\n3、单击 Log In ，输入用户名和密码，然后再次单击Log In打开WordPress站点。\n\n登录后，您就可以根据需要创建内容进行发布了。至此您已完成WordPress的搭建。\n\n4、您可以单击Write your first blog post，开始编写您的第一篇博客。\n\n5、编写完成您的第一篇博客后，单击publish发布。\n\n6、在左侧导航栏，单击All Posts查看已发布的帖子。\n\n五、Wordpress汉化\n1、进入WordPress官方中文网站：https://cn.wordpress.org/\n2、点击【获取WordPress】\n\n3、下拉点击【下载.tar.gz】，下载中文版WordPress压缩包并解压。\n\n4、用SFTP工具连接到云服务器，将刚才解压的文件夹中的 wordpress/wp-content/languages 复制到服务器的 /var/www/html/wp-blog/wp-content 中。\n\n5、执行以下命令，重启Apache服务。\n1systemctl restart httpd\n6、进入WordPress管理台，找到【Setting】&gt;【General】&gt;【Site Language】，改为简体中文并保存。\n\n","plink":"https://hs-zhangsan.github.io/posts/centos&wordpress/"},{"title":"测试文件下载","date":"2022-11-28T19:45:52.000Z","date_formatted":{"ll":"Nov 28, 2022","L":"11/28/2022","MM-DD":"11-28"},"updated":"2023-03-31T11:45:37.382Z","content":"这篇文章用来测试文件下载功能\n先来试一下 PDF\n点击下载\nLinux命令行大全\n点击下载：Linux命令行大全\n再来试一下图片\n\n\n\n点击下载\n点击下载\n然后是 MP3 音频\n下载链接：http://zhangsan.works/posts/test_file_download/碧波摇篮曲.mp3/\n碧波摇篮曲\n好听的\n总结\n目前的问题：\n所有的文件（图片、pdf 和 mp3）都可以通过  的形式生成链接，然后进去查看文件和下载，但是并不是点击链接直接下载。另外不知道为什么资源文件夹用不了，而我的封面就是直接用资源文件夹里的图片的，但是文章内所有文件都用不了。\n还有图片，除了上面的通用方法之外，就连普通的引用本地文件都不行了，不管是绝对路径还是相对路径。而我之前在 测试插入图片 这篇文章中已经测试了可以用。\n","thumbnail":"C:\\Files\\markdown-images202211281946795.jpeg","plink":"https://hs-zhangsan.github.io/posts/test_file_download/"},{"title":"测试插入图片","date":"2022-11-28T13:30:31.000Z","date_formatted":{"ll":"Nov 28, 2022","L":"11/28/2022","MM-DD":"11-28"},"updated":"2023-03-31T11:45:37.381Z","content":"这篇文章用来测试插入图片\n先试一下图床（虽然说肯定没什么问题。。）\n先来一张\n\n再来一张长屏的\n\n再试一下本地图片\n先是绝对路径\n\n然后是相对路径（资源文件夹）\n\n源代码如下：\n\n结论：失败成功\n插入本地图片失败，不知道哪里出了问题，懒得再研究，直接统一用图床。\n更新：插入本地图片只能用绝对路径，相对路径不知道哪里出了问题。嗯，还是直接用图床。\n更新：之前应该是操作失误导致失败的，重新测试了一下又可以了。\n具体地，修改博客根目录的 _config.yml 配置文件，找到 post_asset_folder 修改为 true 开启文章文件夹。然后新建文章的时候在博客根目录用 hexo new post_name 创建，这样就会在文章目录内创建名为 post_name.md 文件的同时创建名为 post_name 的资源文件夹，然后与文章相关的文件在文章内直接引用就可以了。如 post_name 文件夹中有名为 test.jpg 的图片，则引用格式为 ![](test.jpg)。当然，也可以直接使用绝对路径。而我之前把文章标题和文章文件夹名字都改了所以导致错误，这也是这篇文章的日期为什么在后面，因为之前的删了重写了。（如上图所示使用本地图片源代码）\n但是经过测试，使用本地图片的话，由于博客是部署在 GitHub 上的，所以图片加载非常非常慢，所以实际使用还是上传到图床再使用图片链接（我用的腾讯云COS）。\n更新：我去，刚看了一下才发现，我在 测试下载文件功能 这篇文章中使用的封面大小有 50 多 MB，一度让我连图床都上传不上去，传上去之后也加载的贼慢，然后觉得奇怪看了一下图片属性才发现那么大，我说怎么会那么慢。。。\n然后部署的时候，\n\nGitHub最大建议才50MB。。。错了错了，我换还不行么，你说一个图片整这么大这合理吗？\n所以结论是，一般情况下还是可以用本地图片的，虽然会有点慢但是还可以接受。而且都用 hexo 了就图完全本地化，用本地图片也不用担心图床过期什么的。（虽然我还是用图床）\n","thumbnail":"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/654/202211252057512.jpg","plink":"https://hs-zhangsan.github.io/posts/test_insert_image/"},{"title":"测试评论系统","date":"2022-11-27T14:12:26.000Z","date_formatted":{"ll":"Nov 27, 2022","L":"11/27/2022","MM-DD":"11-27"},"updated":"2023-03-31T11:45:37.382Z","content":"这篇文章用来测试评论系统\n失败！\n","thumbnail":"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/654/202211271413591.png","plink":"https://hs-zhangsan.github.io/posts/test_comment/"},{"title":"测试插入音视频","date":"2022-11-26T09:05:31.000Z","date_formatted":{"ll":"Nov 26, 2022","L":"11/26/2022","MM-DD":"11-26"},"updated":"2023-03-31T11:45:37.381Z","content":"这篇文章用来测试插入音视频\n先来测试一下 html 直接嵌入\n首先是B站视频\n\n然后是优酷（迪迦奥特曼外传 远古复活的巨人）\n\n再来（德凯奥特曼 日配版 第1集）\n\n接着来（德凯奥特曼 日配版 第18集）\n\n还来（德凯奥特曼 中配版 第18集）\n\n再然后是网易云音乐\n\n最后是qq音乐\nqq音乐竟然不支持外链播放器？？\n然后又试了一下酷狗、咪咕，结果都不支持生成外链播放器，难怪所有人用的都是网易云，是我想当然了。。\n接着测试一下用插件嵌入更多音视频\n用个屁的插件！\n没有需求不要创造需求。\n用插件也简单，下载好插件直接插入就好了，像什么 H5 原生音视频和各种视频播放平台都可以支持。一般也用不到就不再测试了。\n总结\n直接用 html 插入支持的音视频就可以了。插件暂时用不到。\n首先是视频\n视频的话要注意，默认的代码可能看着不太爽，可以自己优化一下改一下参数（比如这篇文章我只改了b站的视频，优酷的没改，所以看着很蠢），比如b站的画质（虽然有 1080p，但是切换不了，最多 720p）、弹幕什么的。\n优酷的视频只能 720p 了，需要会员的东西一律不能用，比如高贵的 1080p，还有需要会员的视频也不能插入，我放个搜出来排在第一的德凯奥特曼竟然都不行！（为什么这逼奥特曼 18 集只有第 18 集要会员，而且只有一集要会员所有的都不能放🤬）\n又试了一下，刚开始提示没有权限不能播放，不知道为什么又可以了，只有要会员的第 19 集不能放（外面显示 18 集，只有第 18 集要会员，进去了之后又变成了 19 集，只有第 19 集要会员放不了。看不懂看不懂。。。）\n还有爱奇艺，压根不支持。\n然后是音频\n目前貌似只有网易云音乐能用，也可以改一下自动播放、播放器大小什么的，然后也就没啥好说的了。。\n以上。\n","thumbnail":"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/654/202211261032402.jpg","plink":"https://hs-zhangsan.github.io/posts/test_insert_audio&video/"},{"title":"测试嵌入PDF","date":"2022-11-25T20:22:45.000Z","date_formatted":{"ll":"Nov 25, 2022","L":"11/25/2022","MM-DD":"11-25"},"updated":"2023-03-31T11:45:37.381Z","content":"这篇文章用来测试 pdf 嵌入\n注意：移动端不支持（hexo 竟然不支持高亮？？只能加粗了）\n更新：vivo 手机测试，chrome 可以下载但是不能正常显示，夸克浏览器和 vivo 原生浏览器都不能显示。推测 iOS 或者其他安卓手机一样。\n另外，由于本博客部署在 GitHub Page 上，所以 pdf 过大时加载很慢。（可以挂梯子解决）\n首先是比较小的 pdf\n\n\n\t\n    \n\t\n\n\n\n然后是大一点的 pdf\n\n\n\t\n    \n\t\n\n\n\n最后试一下没有目录（书签？）的 pdf\n不好意思，由于现在 markdown 多级标题自动形成目录，所以没有目录的 pdf 还真没找到。。。\n\n\n\t\n    \n\t\n\n\n\n总结：效果还行，可以用\n","thumbnail":"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/654/202211252027510.jpg","plink":"https://hs-zhangsan.github.io/posts/test_embed_pdf/"},{"title":"Hello World","date":"2022-11-02T11:56:12.553Z","date_formatted":{"ll":"Nov 2, 2022","L":"11/02/2022","MM-DD":"11-02"},"updated":"2023-03-31T11:45:37.380Z","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post\n1$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n1$ hexo server\nMore info: Server\nGenerate static files\n1$ hexo generate\nMore info: Generating\nDeploy to remote sites\n1$ hexo deploy\nMore info: Deployment\n","plink":"https://hs-zhangsan.github.io/posts/hello_world/"},{"title":"往事","date":"2015-12-29T23:52:55.000Z","date_formatted":{"ll":"Dec 29, 2015","L":"12/29/2015","MM-DD":"12-29"},"author":"李大圣","updated":"2023-03-31T11:45:37.380Z","content":"又想起了那个夜晚\n五年前的夜晚\n黑夜，风雪\n大概正好就是这个时间\n也许是九点，十点，\n或者十一点，十二点\n在周围游荡了一圈之后\n我又不自觉得走到了学校门口\n距离村子，距离家\n不过一二百米的学校门口\n四下，\n黑夜中白茫茫的一片\n那是积雪反射的不知何处而来的光\n学校里不复白日的热闹\n从校门口向里边望去\n操场，教室，商店，走廊……\n漆黑一片\n旁边村子的住宅还有几户人家亮着灯\n有些刺眼的光从拉着窗帘的窗户照射出来\n耳旁只有寒风的呼啸\n听不见其他任何声音\n射出光的窗户那边在干什么？\n一家人围着火炉看电视？\n大概吧，\n不然还能是什么呢？\n我没有对窗户那边产生丝毫兴趣\n脑袋里也没有出现任何问题\n我只知道\n在这边听不到窗户那边的声音，\n也许别人只是很安静的干着自己的事情吧\n和我又有什么关系呢？\n不知何时停在了学校门口\n也许走到这里的时候自然的停了吧\n在这样风雪交加的夜晚\n穿着并不算厚的衣服走在外边\n这并不是一件容易的事\n但你只要走就好了\n只要没死就没什么大不了的事\n走是肯定死不了的\n更难的是走着走着停了下来\n我回来这里是干什么来着？\n好像是想随便走走，\n说不定能熬到天亮？\n又好像是因为某种不明的心理原因\n让我在无处可去的时候回到了最熟悉的地方？\n又或者\n这里离家比较近？\n哦对\n想起来了\n在离开最后一个地方的时候\n走在路上思考怎么度过这个夜晚的时候\n想到了学校旁边好像有个麦秆堆来着\n死是肯定不至于的\n这不就想到了办法么？\n冷好像竟然不是那么冷\n但直接睡在室外的环境是不现实的\n会不会在半夜冻死还不好说\n想要睡着首先是个问题\n麦秆是个好东西呀\n虽然外边覆盖了一层雪\n但只要在底下挖出一个洞\n可以想象\n这会是个很舒服的窝\n不知为何\n我又想起了那只被我遗忘的狗\n他死在了一个麦秆堆里\n是冻死的？\n还是饿死的？\n也许都有吧\n总之\n他是因为我而死的\n我把它带了回来\n又把他的存在遗忘了\n突然\n我对这个死过一只狗的的麦秆堆有些抵触\n虽然我清楚\n这不是同一个麦秆堆\n为什么会抵触呢？\n是愧疚在作祟？\n或者只是单纯的嫌弃和厌恶？\n谁知道呢\n轻轻甩甩脑袋\n将这些乱七八糟的想法丢掉\n嘶\n脑袋竟被晃得疼\n是冷的吗？\n还是饿的？\n管他呢\n问题不大\n新的问题又冒了出来\n在这个季节\n在这个天气\n麦秆堆是流浪狗的好去处\n万一这里被流浪狗占据了怎么办？\n赶走就是了\n那狗毛怎么办？\n或者有狗屎呢？\n虽然雪夜没那么黑\n但是想分辨出这些东西还是不那么的容易\n我可以晚上睡在麦秆堆里并不觉自卑羞耻\n白天依旧学习玩耍，该怎样怎样\n我不会刻意掩饰\n也不会主动吹嘘\n没人知道无所谓\n有人知道也不影响\n没人会说什么\n也没人敢说什么\n不会有人因此看低我\n或者还是会有\n那些不认识我的人？\n无所谓\n能这样想的人都是垃圾\n他们再怎么想对我也没影响\n倒是可以预见的\n很多人眼中我的高度再次拔高一截\n也许更多的人\n对我抱有可笑的同情和不解？\n这么一想又太复杂了\n管他呢\n这一个学校的人都认识我\n但我认识的就那么几个\n难不成\n每一个对我有想法的人我都得去认识了解？\n那多累呀\n但是\n睡在麦秆里和身上占了狗屎不一样\n那太丢人了\n而且一旦屎弄到我本身就不算厚的衣服上\n我根本没法也没地方去洗\n更不可能去扔\n那就很麻烦了\n管他呢\n又想的太多了\n得赶快了\n果然一停下来就一点都不想动弹了\n明明还在风雪里边站着呢\n要是有狗的话\n赶走后把麦秆再往外挖一点就行了\n四下转了转\n依旧是那个夜\n没看到好像存在于记忆中的麦秆堆\n我记错了？\n问题不大\n麦秆堆嘛\n多的是\n再找就是了\n从衣兜里掏出手\n使劲搓了搓脸\n又原地活动了一阵\n抖了抖身上的雪\n把本就不多的能量和精力再次消耗大半\n转过身背向学校\n准备再次移动……\n","thumbnail":"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/654/202211022254638.jpg","plink":"https://hs-zhangsan.github.io/posts/the_past/"},{"title":"about","date":"2020-11-02T23:51:13.000Z","date_formatted":{"ll":"Nov 2, 2020","L":"11/02/2020","MM-DD":"11-02"},"updated":"2023-03-31T03:45:37.364Z","content":"I, ZhangSan, just be an ordinary genius.\nThis is my official account, although I don’t know what to write on it yet. You might as well subscribe first, at least it won’t bother you with useless notifications now and then.\n\nThen, if there is anything you can add me on WeChat. (Indicate the intention, not necessarily agree)\n\n","plink":"https://hs-zhangsan.github.io/about/"},{"title":"timeline","date":"2022-11-28T16:47:42.000Z","date_formatted":{"ll":"Nov 28, 2022","L":"11/28/2022","MM-DD":"11-28"},"updated":"2024-02-24T13:50:32.509Z","content":"\n域名更换为：https://taisui.tech/\n2024-02-24 21:42:00\n\n新增「leetcode」板块，开始在力扣刷题并记录。\n2023-01-18 11:25:00\n\n之前忘了。\n截至今日，博客情况如下：\n基于 hexo &amp; inside，部署在 GitHub Page。\n绑定自定义域名为：https://zhangsan.works/\n完成一系列基础配置。\n完成「嵌入pdf、插入图片、插入音视频、设置永久链接、下载文件功能」测试。\n评论系统测试失败。\n2022-11-28 21:35:56\n往事，不提也罢。\n2015-12-29 23:55:34\n","plink":"https://hs-zhangsan.github.io/timeline/"},{"title":"142-环形链表II","date":"2023-01-29T11:41:43.000Z","date_formatted":{"ll":"Jan 29, 2023","L":"01/29/2023","MM-DD":"01-29"},"updated":"2023-03-31T11:45:37.365Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n不允许修改 链表。\n示例 1：\n\n123输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。\n示例 2：\n\n123输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。\n示例 3：\n\n123输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。\n提示：\n\n链表中节点的数目范围在范围 [0, 104] 内\n-105 &lt;= Node.val &lt;= 105\npos 的值为 -1 或者链表中的一个有效索引\n\n进阶：你是否可以使用 O(1) 空间解决此题？\n题解\n解题思路\n\n这道题主要考查两点：\n\n判断链表是否有环（也即 141.环形链表）\n若链表有环，怎么找到环的入口\n\n\n\n判断链表是否有环\n\n使用快慢指针，让 fast 和 slow 都从头结点出发，fast 每次移动两步，slow 每次移动一步，若两个指针相遇，则说明链表有环。\n\n若链表有环，怎么找到环的入口\n\n当快慢指针相遇时，「头结点到入环结点的距离」就等于若干倍的「相遇结点到入环结点的距离（顺着链表方向）」。这意味着什么呢？这就意味着若两个指针同时从头结点和相遇结点出发，每次都移动一步，那么它们最终会在入环结点处相遇。(具体看下面推导过程)\n\n推导证明\n\n\n首先要明确，若相遇则一定是在环内，这个没什么好说的。\n\n\n当 slow 入环后，对 slow 来说，fast 是在追赶它，而且每次都会靠近一个节点，因此一定可以追到。\n\n\n由于 slow  每次只走一步，且 fast 每次都会追到一步，而 fast 距离 slow（相对 fast 追 slow 来说，fast 在 slow 之后）最多不会超过环的所有结点数，因此 fast 一定会在 slow 走完环的一圈之前追到 slow。\n\n\n\n\n再来看看寻找环的入口的过程（这里找张纸对着画一画会很清晰，需要计算，但是很简单）\n\n\n\n\n若链表有环，那么链表可以分为三个部分（顺着链表方向）：\n\n头结点到入环结点的部分，记此部分距离为 a；\n入环结点到相遇节点的部分，记此部分距离为 b；\n相遇部分到入环结点的部分，记此部分距离为 c。\n\n\n\nfast 走过的距离为 len1 = a + b + n * (b + c)（n 为 fast 在环内走了 n 圈才遇到 slow ）\n\n\nslow 走过的距离为 len2 = a + b（前面说过，一定是在 slow 走完环的一圈之前相遇，所以 slow 走过的距离不是 len2 = a + n * (b + c) + b）。\n\n\n又因为 fast 每次走两步，slow 每次走一步，所以 fast 走过的距离等于二倍的 slow 走过的距离：len1 = 2 * len2。\n\n\n联立以上三式可得：a + b + n * (b + c) = 2 * (a + b)。\n\n\n化简整理后可得：a = (n - 1) * (b + c) + c（由于要求 a，所以整理成其他变量和 a 的关系的形式）。\n\n\n这个式子说明：若两个指针同时从头结点和相遇结点出发，每次都移动一步，那么它们最终会在入环结点处相遇，此时从相遇结点出发的指针共在环里循环了 n-1 圈。\n\n\n代码\n12345678910111213141516struct ListNode *detectCycle(struct ListNode *head) &#123;    struct ListNode* fast = head;    struct ListNode* slow = head;    while (fast &amp;&amp; fast-&gt;next) &#123;        fast = fast-&gt;next-&gt;next;        slow = slow-&gt;next;        if (fast == slow) &#123;            while (fast != head) &#123;                fast = fast-&gt;next;                head = head-&gt;next;            &#125;            return fast;        &#125;    &#125;    return NULL;&#125;\n复杂度分析\n时间复杂度：O(n)​\n空间复杂度：O(1)​\n总结\n有点印象，知道判断有没有环用快慢指针，然后快指针每次走两步，慢指针每次走一步。寻找环的入口这里，依稀记得要计算，但是不知道要怎么算。看了题解之后也没写出来，又看了代码才写了出来。\n总的来说，做出来之后感觉这道题也不难，但是自己就是做不出来，还是水平太低。\n","plink":"https://hs-zhangsan.github.io/leetcode/142-环形链表II/"},{"title":"151-反转字符串中的单词","date":"2023-02-05T11:03:24.000Z","date_formatted":{"ll":"Feb 5, 2023","L":"02/05/2023","MM-DD":"02-05"},"updated":"2023-03-31T11:45:37.366Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给你一个字符串 s ，请你反转字符串中 单词 的顺序。\n单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。\n返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。\n注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n示例 1：\n12输入：s = &quot;the sky is blue&quot;输出：&quot;blue is sky the&quot;\n示例 2：\n123输入：s = &quot;  hello world  &quot;输出：&quot;world hello&quot;解释：反转后的字符串中不能存在前导空格和尾随空格。\n示例 3：\n123输入：s = &quot;a good   example&quot;输出：&quot;example good a&quot;解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。\n提示：\n\n1 &lt;= s.length &lt;= 104\ns 包含英文大小写字母、数字和空格 ’ ’\ns 中 至少存在一个 单词\n\n进阶：如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。\n题解\n解题思路\n\n\n要将字符串的每一个单词都反转，只需要将整个字符串都反转过来，再将每个单词反转就可以了。又因为字符串中还可能有多余的空格需要移除，所以这道题总共分为三步：\n\n移除多余的空格\n反转整个字符串\n反转每一个单词\n\n\n\n用 “ the sky  is   blue  ” 举例说明，源字符串长度为 21。\n\n移除多余的空格：“the sky is blue”（此时字符串的长度变为了 15）\n反转整个字符串：“eulb si yks eht”\n反转每一个单词：“blue is sky the”\n\n\n\n因为可能有去除空格的操作，所以字符串的长度只可能变短不可能变长，所以可以直接在原字符串上进行操作，这样就不用重新定义一个字符串，空间复杂度达到了 O(1)。\n\n\n另外，需要重点注意一下「移除多余的空格」的操作，最直观的想法就是遍历字符串，遇到空格就执行删除操作,但是，删除数组元素的操作本身最优也就是 O(n) 的时间复杂度，再套上遍历总的时间复杂度就是 O(n2) 了。所以使用双指针法来移除空格，这样时间复杂度就可以降到 $O(n)$ 了。这样时间复杂度 O(n)，空间复杂度 O(1)，基本就把这道题做到极致了。\n\n\n移除元素和反转字符串的操作可以参考我之前的题解：\n\n27.移除元素\n344.反转字符串\n\n\n\n代码\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//反转字符串函数void reverse(char* s, int start, int end) &#123;    while (start &lt; end) &#123;        char temp = s[start];        s[start++] = s[end];        s[end--] = temp;    &#125;&#125;char * reverseWords(char * s)&#123;    // 1. 移除多余空格    int len = strlen(s);    int fast = 0, slow = 0;    // 移除字符串之前的空格    while (s[fast] == &#x27; &#x27;) &#123;        fast++;    &#125;    // 移除单词之间多余的空格    while (fast &lt; len - 1) &#123;        if (s[fast] == &#x27; &#x27; &amp;&amp; s[fast + 1] == &#x27; &#x27;) &#123;            fast++;        &#125; else &#123;            s[slow++] = s[fast++];        &#125;    &#125;    // 移除字符串后面的空格    if (s[fast] == &#x27; &#x27;) &#123;        s[slow] = &#x27;\\0&#x27;;    &#125; else &#123;        s[slow++] = s[fast];        s[slow] = &#x27;\\0&#x27;;    &#125;        // 2. 反转整个字符串    reverse(s, 0, slow - 1);        // 3. 反转每一个单词    for (int i = 0; i &lt; slow; i++) &#123;        int j = i;        while (j &lt; slow &amp;&amp; s[j] != &#x27; &#x27;) &#123;            j++;        &#125;        reverse(s, i, j - 1);        i = j;    &#125;    return s;&#125;\n复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(1)\n总结\n还是挺难的，乍一看没有头绪，看了之前的题解才想起思路了，同时也发现之前的题解写的稀烂。做的过程也磕磕巴巴的，但总归是搞定了。\n","plink":"https://hs-zhangsan.github.io/leetcode/151-反转字符串中的单词/"},{"title":"19-删除链表的倒数第N个结点","date":"2023-01-27T11:52:22.000Z","date_formatted":{"ll":"Jan 27, 2023","L":"01/27/2023","MM-DD":"01-27"},"updated":"2023-03-31T11:45:37.367Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n示例 1：\n\n12输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5]\n示例 2：\n12输入：head = [1], n = 1输出：[]\n示例 3：\n12输入：head = [1,2], n = 1输出：[1]\n提示：\n\n链表中结点的数目为 sz\n1 &lt;= sz &lt;= 30\n0 &lt;= Node.val &lt;= 100\n1 &lt;= n &lt;= sz\n\n进阶：你能尝试使用一趟扫描实现吗？\n题解\n解题思路\n\n链表问题首先考虑使用哑结点。观察一下这道题，是有可能处理头结点的，那就直接使用哑结点，避免单独处理特殊情况。\n这道题是一道双指针的经典题，使用快慢指针，让 fast 先走 n 步，然后 fast 和 slow 同时移动直到fast 指向链表末尾空结点，此时 slow指向的就是倒数第 n 个结点，然后删除结点即可。\n需要注意的是，由于删除结点的操作是：「让要删除节点的前一个结点的 next 越过要删除的节点指向其后一个结点」，要操作的结点是要删除的节点的前一个结点，因此 fast 实际上要先走 n+1 步而不是 n 步。此外注意 return dummyHead-&gt;next 而不是 return head。\n最后一定一定记得释放结点。\n\n代码\n123456789101112131415161718192021222324struct ListNode* removeNthFromEnd(struct ListNode* head, int n)&#123;    //设置哑结点    struct ListNode* dummyHead = malloc(sizeof(struct ListNode));    dummyHead-&gt;next = head;    //设置双指针    struct ListNode* fast = dummyHead;    struct ListNode* slow = dummyHead;    //fast 先走 N+1 步    while (n--) &#123;        fast = fast-&gt;next;    &#125;    fast = fast-&gt;next;    //fast 和 slow 同时向后移动直到 fast 指向 NULL    while (fast) &#123;        fast = fast-&gt;next;        slow = slow-&gt;next;    &#125;    //删除结点并释放结点空间    struct ListNode* temp = slow-&gt;next;    slow-&gt;next = slow-&gt;next-&gt;next;    free(temp);    //注意返回的是 dummy-&gt;next 而不是 head    return dummyHead-&gt;next;&#125;\n复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(1)\n总结\n这道题有印象，一眼快慢指针，然后秒了。再看了一下之前的题解，写的是真他妈得好，题解为了讲清楚是让 fast 初始化为 dummyHead，然后走 n+1 步，我这次直接让 fast 初始化为 head，就不用再单独让 fast 多走一步，作为题解肯定是之前的更清晰一点，只能说写的是真他妈得好。\n另外之前的题解有个评论说为什么不返回 head，感觉 head 也是可以的，犯了经典的错误，我还在题解中专门说了「此外注意 return dummyHead-&gt;next 而不是 return head」，链表内题目还是得多画一画，而不是只靠想。另外还有一个评论说没有释放结点。。。害，不光之前，这次也忘了，因为是在力扣上做题，所以真的没有意识到，要改要改。。。\n不管怎样，这题秒了终于让我找回一点自信了哭唧唧╥﹏╥…\n","plink":"https://hs-zhangsan.github.io/leetcode/19-删除链表的倒数第N个结点/"},{"title":"202-快乐数","date":"2023-02-01T15:19:45.000Z","date_formatted":{"ll":"Feb 1, 2023","L":"02/01/2023","MM-DD":"02-01"},"updated":"2023-03-31T11:45:37.367Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n编写一个算法来判断一个数 n 是不是快乐数。\n「快乐数」 定义为：\n\n\n对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\n\n\n然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。\n\n\n如果这个过程 结果为 1，那么这个数就是快乐数。\n\n\n如果 n 是 快乐数 就返回 true ；不是，则返回 false 。\n示例 1：\n1234567输入：n = 19输出：true解释：12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1\n示例 2：\n12输入：n = 2输出：false\n提示：\n\n1 &lt;= n &lt;= 231 - 1\n\n题解\n解题思路\n\n先理解题目要求，这道题的要点一共有两个：\n\n做完某次计算后等于 1，return true，不必多说。\n在计算的过程中无限循环始终不变为 1，也就是说，它的计算结果 sum 会重复出现，这是本题的关键，若在循环的过程中 sum 重复出现，说明它永远不可能等于 1，return false。\n\n\n理解了以上两点再来看就比较简单了，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。在本题中，使用数组作为哈希表用来存放每次计算的结果，初始数组都为 0，每次计算后将结果作为下标映射到数组元素。若对应数组元素为 0，说明此结果没得到过，将其改为 1；若为 1，说明计算结果已经重复，return false。\n那么数组的大小怎么确定呢？题目中告诉了 n 的大小最大不超过 2^31-1，即最大不超过 10 位数，也就是说，计算的结果最大不超过 9^2*10 也就是 810，再稍微大一点就行了，所以是820，这也是为什么本题能用数组的原因（我能说是因为C语言没有 set 想要用的话还得现现场手搓么哭唧唧o(TヘTo)）。\n注意，使用数组来做哈希的题目，是因为题目都限制了数值的大小。而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。\n\n代码\n123456789101112131415161718192021222324//计算的过程函数，我没重点讲，很简单看一下代码就好了int getSum(int n) &#123;    int sum = 0;    while (n) &#123;        sum += (n % 10) * (n % 10);        n /= 10;    &#125;    return sum;&#125;bool isHappy(int n)&#123;    int sum = getSum(n);    int hash[820] = &#123;0&#125;;    while (sum != 1) &#123;        if (hash[sum] == 1) &#123;            return false;        &#125; else &#123;            hash[sum]++;        &#125;        sum = getSum(sum);    &#125;    return true;&#125;\n复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(1)\n总结\n昨天的题把我整自闭了，看了题解又看了视频，还去搜了一下C语言的Hash，结果都能懂，但是要拿c写set还是太麻烦了，我看到最后还是放弃了，好在发现拿数组也是可以做的，甚至效率更高，总算是把题做了，但是没写题解。\n今天的一看，不出意外卡子哥又用的set，emm算了不能直接摆，先看看题，emm没感觉，再看看以前的提交，欸这么简单？反过来再看看题，再看看题解，再看看之前的代码，eng！这么简单，我起了，直接秒了，有什么好说的。\n总之呢，我决定了，去他妈的C语言写set，以后能用数组就用数组，不能用就不做了，后面学了其他语言打不了再专项训练一下哈希表，不出意外的话我再也见不到c语言的set了。emm，map也是。。。\n","plink":"https://hs-zhangsan.github.io/leetcode/202-快乐数/"},{"title":"203-移除链表元素","date":"2023-01-23T10:06:07.000Z","date_formatted":{"ll":"Jan 23, 2023","L":"01/23/2023","MM-DD":"01-23"},"updated":"2023-03-31T11:45:37.368Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\n示例 1：\n\n12输入：head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5]\n示例 2：\n12输入：head = [], val = 1输出：[]\n示例 3：\n12输入：head = [7,7,7,7], val = 7输出：[]\n提示：\n\n列表中的节点数目在范围 [0, 104] 内\n1 &lt;= Node.val &lt;= 50\n0 &lt;= val &lt;= 50\n\n题解\n解题思路\n\n链表的增删操作比较简单，\n\n删除某个结点只需要将其前一个结点的 next 指向其后一个结点即可。如果使用 c/c++ 千万记得释放内存！\n在某两个结点之间增加新的结点只需将前一个结点的 next 指向要增加的结点，然后将新增加结点的 next 指向后一个结点即可。\n\n\n另外，在遇到链表类题目时，都可以无脑用哑结点。所谓哑结点，即设置一个虚拟头结点（哑结点），让哑结点 dummyHead 的 next 指向原头结点，这样原链表的所有节点就都可以按照统一的方式进行移除了。最后在 return 的时候记得 return dummyHead-&gt;next。哑结点的好处可以参考卡子哥的这篇文章：链表：听说用虚拟头节点会方便很多？，这里不再赘述。\n最后，如果使用 c/c++ 移除链表结点，一定记得清理内存，哪怕在力扣中没有手动在内存中删除这个结点，依然也是可以通过的。其他语言例如Java、Python，都有自己的内存回收机制，就不用自己手动释放了。\n\n代码\n123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     struct ListNode *next; * &#125;; */struct ListNode* removeElements(struct ListNode* head, int val)&#123;    struct ListNode* dummyHead = malloc(sizeof(struct ListNode));    dummyHead-&gt;next = head;    struct ListNode* curr = dummyHead;    while (curr-&gt;next) &#123;        if (curr-&gt;next-&gt;val == val) &#123;            struct ListNode* temp = curr-&gt;next;            curr-&gt;next = curr-&gt;next-&gt;next;            free(temp); //释放已删除的结点        &#125; else &#123;            curr = curr-&gt;next;        &#125;    &#125;        return dummyHead-&gt;next;&#125;\n复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(1)​\n\n注意，链表的增删实际上都是 O(1) 操作，但是操作时需要先从头结点查找到要操作的结点，查找的时间复杂度是 O(n)。\n\n总结\n删除链表节点很基础，能知道逻辑，但是写出来还是磕磕碰碰的。乌鱼子━━(￣ー￣*|||━━\n","plink":"https://hs-zhangsan.github.io/leetcode/203-移除链表元素/"},{"title":"209-长度最小的子数组","date":"2023-01-21T10:46:02.000Z","date_formatted":{"ll":"Jan 21, 2023","L":"01/21/2023","MM-DD":"01-21"},"updated":"2023-03-31T11:45:37.369Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n示例1：\n123输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n示例2：\n12输入：target = 4, nums = [1,4,4]输出：1\n示例3：\n12输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0\n题解\n解题思路\n\n我们很容易想到，这道题的暴力解法就是使用两个 for 循环不断寻找符合条件的子数组，这里不再赘述。\n先简单介绍一下滑动窗口，所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。滑动窗口是数组操作中一个重要的方法，本质上还是双指针法的一种。\n本题的关键在于窗口的起始位置如何移动，如以下代码所示：\n\n1234while (sum &gt;= target) &#123;    //若窗口内子数组和大于 target    minLength = fmin(minLength, end - start + 1);   //这里更新最小长度    sum -= nums[start++];   //这里是滑动窗口的妙处所在，不断变更起始位置 start&#125;\n\n可以发现滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将 $O(n^2)$ 的暴力解法降为 $O(n)$。\n\n代码\n12345678910111213int minSubArrayLen(int target, int* nums, int numsSize)&#123;    //这里注意细节，求最小值时要将变量初始化为理论最大值。反之亦然。    int minLength = INT_MAX;    int sum = 0;    //窗口内元素之和    for (int start = 0, end = 0; end &lt; numsSize; end++) &#123;        sum += nums[end];        while (sum &gt;= target) &#123;     //若窗口内子数组和大于 target            minLength = fmin(minLength, end - start + 1);//更新最小子数组长度            sum -= nums[start++];   //这里是滑动窗口的妙处所在，不断变更起始位置 start        &#125;    &#125;    return minLength == INT_MAX ? 0 : minLength;&#125;\n复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(1)​\n\n注意，虽然 for 循环里面还有一个 while 一共两重循环，但是时间复杂度是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是 2 × n 也就是$O(n)$。大部分情况下两重循环还是$O(n^2)$，具体情况具体分析。\n\n总结\n还是一样，一眼滑动窗口，但是就是不知道怎么写，看了之后就会了。\n相关题目\n\n904.水果成篮\n76.最小覆盖子串\n\n","plink":"https://hs-zhangsan.github.io/leetcode/209-长度最小的子数组/"},{"title":"206-反转链表","date":"2023-01-25T19:07:34.000Z","date_formatted":{"ll":"Jan 25, 2023","L":"01/25/2023","MM-DD":"01-25"},"updated":"2023-03-31T11:45:37.368Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1：\n\n12输入：head = [1,2,3,4,5]输出：[5,4,3,2,1]\n示例 2：\n\n12输入：head = [1,2]输出：[2,1]\n示例 3：\n12输入：head = []输出：[]\n提示：\n\n链表中节点的数目范围是 [0, 5000]\n-5000 &lt;= Node.val &lt;= 5000\n\n进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\n题解\n方法一：双指针法\n\n反转链表比较简单，很容易想到，从前向后遍历链表，然后把每个结点的 next 指向前一个结点就好。\n具体实现中，首先需要两个指针，一个 curr 指针在遍历到每个结点进行操作，一个 prew 指针指向 curr 的前一个结点。其次，由于 curr-&gt;next 指向 prew，导致原来的 curr 的下一个结点失去引用，所以还需要一个指针 temp 用来保存后一个结点。\n\n代码\n123456789101112131415//双指针法struct ListNode* reverseList(struct ListNode* head)&#123;    struct ListNode* curr = head;    struct ListNode* prew = NULL;    while (curr) &#123;        //保存下一个结点        struct ListNode* temp = curr-&gt;next;        //反转结点        curr-&gt;next = prew;        //更新 curr 和 prew 指针        prew = curr;        curr = temp;    &#125;    return prew;&#125;\n方法二：递归法\n\n递归法和双指针法是一样的逻辑，同样是当 curr 为空的时候循环结束，不断将 curr 指向 pre 的过程。具体可以对比双指针法和下面的代码，代码已经详细注释，理解起来应该相当容易。\n\n代码\n从前向后反转指针指向\n123456789101112131415161718192021//递归法（从前向后反转指针指向）struct ListNode* reverse(struct ListNode* curr, struct ListNode* prew) &#123;    if (!curr) &#123;        return prew;    &#125;        struct ListNode* temp = curr-&gt;next;    curr-&gt;next = prew;    //可以与双指针法对比，其实逻辑是一样的，只是用递归实现而已    //下面的代码省去了双指针中更新 curr 和 prew 的过程，直接在递归中引用    return reverse(temp, curr);&#125;struct ListNode* reverseList(struct ListNode* head)&#123;    //这里也是省去了初始化 curr 和 prew 的过程，直接在递归中引用    //下面正文中的代码和注释中的代码是等价的    //struct ListNode* curr = head;    //struct ListNode* prew = NULL;    //return reverse(curr, prew);    return reverse(head, NULL);&#125;\n\n这时候聪明的同学就会说了，上面的双指针法和递归法实质上都是从前往后反转指针指向，那么能不能从后往前反转指针指向呢？\n答案是当然能了，具体代码如下，已经详细注释。\n\n12345678910111213141516//递归法（从后向前反转指针指向）struct ListNode* reverseList(struct ListNode* head)&#123;    //递归结束条件判断    if (!head || !head-&gt;next) &#123;        return head;    &#125;    //调用递归，反转第二个结点后的结点    struct ListNode* newHead = reverseList(head-&gt;next);    //反转头结点与第二个结点    head-&gt;next-&gt;next = head;    //此时 head 是尾结点，尾结点需要指向 NULL    head-&gt;next = NULL;    return newHead;&#125;\n写题解不易，若对你有帮助，点赞评论再走吧。(～￣▽￣)～\n总结\n看了一眼题解直接秒了，用的双指针，递归没做，看了一下之前的题解脑子里过了一遍。\n","plink":"https://hs-zhangsan.github.io/leetcode/206-反转链表/"},{"title":"24-两两交换链表中的结点","date":"2023-01-26T18:10:40.000Z","date_formatted":{"ll":"Jan 26, 2023","L":"01/26/2023","MM-DD":"01-26"},"updated":"2023-03-31T11:45:37.369Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n示例 1：\n\n12输入：head = [1,2,3,4]输出：[2,1,4,3]\n示例 2：\n12输入：head = []输出：[]\n示例 3：\n12输入：head = [1]输出：[1]\n提示：\n\n链表中节点的数目在范围 [0, 100] 内\n0 &lt;= Node.val &lt;= 100\n\n题解\n方法一：迭代\n\n首先，链表类题目无脑用哑结点。\n其次，以 head = [1,2,3,4] 为例，操作前链表为：dummyHead -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; null，交换一对节点的操作分为三步进行：\n\n第一步直接越过下一个节点1，将当前节点 dummyHead 的 next 指向节点2；\n第二步再将节点2的 next 指向节点1；\n第三步将节点1的 next 指向节点3，与原链表重新连接起来。\n\n\n以上三步便可将一对节点交换，操作后链表变为：dummyHead -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 -&gt; null，之后遍历链表重复进行交换每对数组即可（自己找张纸画一画链表类的问题很简单的）。\n\n代码\n123456789101112131415161718192021222324//迭代版本struct ListNode* swapPairs(struct ListNode* head)&#123;    //设置哑结点，便于后续操作    struct ListNode* dummyHead = malloc(sizeof(struct ListNode));    dummyHead-&gt;next = head;    struct ListNode* curr = dummyHead;    while (curr-&gt;next &amp;&amp; curr-&gt;next-&gt;next) &#123;        //记录临时节点        struct ListNode* temp1 = curr-&gt;next;        struct ListNode* temp2 = curr-&gt;next-&gt;next-&gt;next;        curr-&gt;next = curr-&gt;next-&gt;next;  //第一步        curr-&gt;next-&gt;next = temp1;       //第二步        curr-&gt;next-&gt;next-&gt;next = temp2; //第三步        //注意这里，curr 只移动两位，        //也就是说，移动到下一对要交换的节点之前        //以上述举例为例，curr 只移动到节点2而不是节点3        curr = curr-&gt;next-&gt;next;    &#125;    return dummyHead-&gt;next;&#125;\n复杂度分析\n时间复杂度：O(n)​\n空间复杂度：O(1)​\n方法二：递归\n\n而聪明的同学都知道，递归和循环大多是可以相互替代的，那么这道题呢，也是可以用递归完成的。（PS：一般情况下，建议使用循环而不是递归）\n\n代码\n12345678910111213//递归版本struct ListNode* swapPairs(struct ListNode* head)&#123;    //递归结束条件    if (!head || !head-&gt;next) &#123;        return head;    &#125;    struct ListNode* newHead = head-&gt;next;  //保存下一个节点    head-&gt;next = swapPairs(newHead-&gt;next);  //进入递归    newHead-&gt;next = head;                   //交换节点    return newHead;&#125;\n复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(1)\n总结\n逻辑自己画了画很容易想明白，当然还不够明白，不清晰不透彻，所以没写出来，然后看了一眼题解，豁然开朗，真他妈简单，然后秒了，然后又看了看我之前写的题解，写的是真他妈的好啊，再然后发现之前还用了递归写了，我竟然都没想到（虽然说一般也不会用递归呵呵呵），也懒得再用递归写一遍了，然后只看了看之前的代码，一眼看过去没看懂，然后也懒得看了。。。\n总结：我好像是重新开始一样。。。\n","plink":"https://hs-zhangsan.github.io/leetcode/24-两两交换链表中的节点/"},{"title":"242-有效的字母异位词","date":"2023-01-30T09:54:35.000Z","date_formatted":{"ll":"Jan 30, 2023","L":"01/30/2023","MM-DD":"01-30"},"updated":"2023-03-31T11:45:37.370Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。\n示例 1:\n12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true\n示例 2:\n12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false\n提示:\n\n1 &lt;= s.length, t.length &lt;= 5 * 104\ns 和 t 仅包含小写字母\n\n进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\n题解\n\n这道题暴力解法就是使用两层 for 循环遍历两个字符串，同时记录字符是否重复出现，不再赘述。\n接着使用哈希表：这道题目中字符串只有小写字符，那么只需要定义一个长为 26 的数组 record，来记录字符串 s 里字符出现的次数。接着需要把字符映射到数组也就是哈希表的索引下标上，因为字符 a 到字符 z 的 ASCII 是 26 个连续的数值，所以字符 a 映射为下标 0，相应的字符 z 映射为下标 25。\n这里有一个实用的技巧：在遍历字符串 s 的时候，只需要将 s[i] - 'a' 所在的元素做 +1 操作即可，并不需要记住字符 a 的 ASCII，只要求出一个相对数值就可以了。然后在遍历字符串 t 的时候，对 t 中出现的字符映射哈希表索引上的数值再做 -1 的操作。这个操作在刷题和日常写代码中会经常用到，很妙。\n最后只需要检查 record，若 record 有不为零的元素，则说明字符串 s 和 t 一定是谁多了字符或者谁少了字符，return false；若 record 数组所有元素都为零，说明字符串 s 和 t 是字母异位词，return true。\n\n代码\n12345678910111213141516171819202122bool isAnagram(char * s, char * t)&#123;    int lenS = strlen(s), lenT = strlen(t);    //若两字符串长度不等，则一定不是字母异位词    if (lenS != lenT) &#123;        return false;    &#125;    //这里是本题的核心代码，注意体会循环里两行代码的妙处    int record[26] = &#123;0&#125;;    for (int i = 0; i &lt; lenS; i++) &#123;        record[s[i] - &#x27;a&#x27;]++;        record[t[i] - &#x27;a&#x27;]--;    &#125;    //若数组中存在不为 0 的元素，则不是字母异位词    for (int i = 0; i &lt; 26; i++) &#123;        if (record[i] != 0) &#123;            return false;        &#125;    &#125;    return true;&#125;\n复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(1)\n总结\n想到了暴力解法的思路，试着写了写没写出来，觉得太麻烦就直接看题解了，我竟然没想着试一下哈希表怎么写？是太怕了，觉得一上来就要手搓哈希表的缘故嘛。。。看了题解发现很简单，做的过程中想直接用指针遍历字符串，然而我TM忘了指针怎么用了！！结果不出意外报错了，然后老老实实计算字符串长度再用下标遍历了。。书也不在身边，是该复习一下指针了哭唧唧。\n相关题目\n\n383.赎金信\n49.字母异位词分组\n438.找到字符串中所有字母异位词\n\n","plink":"https://hs-zhangsan.github.io/leetcode/242-有效的字母异位词/"},{"title":"27-移除元素","date":"2023-01-19T17:52:18.000Z","date_formatted":{"ll":"Jan 19, 2023","L":"01/19/2023","MM-DD":"01-19"},"updated":"2023-03-31T11:45:37.370Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。\n示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n你不需要考虑数组中超出新长度后面的元素。\n题解\n这道题是双指针的经典题目，暴力解法就不再赘述，直接讲双指针的解法。\n\n这是旧版题解\n\n解题思路\n\n首先我们要明确， 数组中的元素不能单独删除，只能覆盖。 （你问为什么？这都不知道你为什么会出现在这里？好吧，原因是 数组的元素在内存地址中是连续的 ）\n回到这道题，移除元素的操作只需要 将其后面的元素依次覆盖前面的 就好。我们很容易想到暴力解法，也就是用两个 for 循环，一个循环遍历数组元素，一个循环更新数组元素。虽然这道题暴力解法也可以过，但是若只是这样我们就不会出现在这里了。(/▽＼)\n（这里我没放暴力的代码，大家可以自己敲出来再进行优化，初学者的话建议不要怕麻烦，没有思路就先写出暴力的解法再考虑能不能优化）\n我们可以使用双指针法，通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作。具体地，遍历数组，快指针和慢指针每次 +1，当位于快指针位置的元素等于要删除的元素时，慢指针停一次，快指针继续递增，每层循环都将快指针位置的元素覆盖至慢指针位置的元素。\n注意以上实现方法并没有改变元素的相对位置。（所以题目的倒数第二句话并没有什么*用）\n\n代码\n12345678910int removeElement(int* nums, int numsSize, int val) &#123;    int fast = 0, slow = 0;    while (fast &lt; numsSize) &#123;        if (nums[fast] != val) &#123;            nums[slow++] = nums[fast];        &#125;        fast++;    &#125;    return slow;&#125;\n复杂度分析\n时间复杂度：O(N)\n空间复杂度：O(1)\n\n\n这是新版题解\n\n解题思路\n\n使用快慢指针，通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n具体地，让两个指针 fast 和 slow 初始都为 0，然后同时向后移动，当遇到 val 时，slow 停下而 fast 继续移动，并在过程中将 nums[fast] 的值赋给 nums[slow] 即可。\n双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。\n\n代码\n12345678910int removeElement(int* nums, int numsSize, int val)&#123;    int fast = 0, slow = 0;    while (fast &lt; numsSize) &#123;        if (nums[fast] != val) &#123;            nums[slow++] = nums[fast];        &#125;        fast++;    &#125;    return slow;&#125;\n复杂度分析\n时间复杂度：O(n)​\n空间复杂度：O(1)​\n总结\n一开始没想到双指针，后面想到了又没写出来。\n总结：长时间不写算法题是这样的，慢慢捡起来就好。\n相关题目\n\n26.删除排序数组中的重复项\n283.移动零\n844.比较含退格的字符串\n977.有序数组的平方\n\n","plink":"https://hs-zhangsan.github.io/leetcode/27-移除元素/"},{"title":"28-找出字符串中第一个匹配项的下标","date":"2023-02-07T14:22:24.000Z","date_formatted":{"ll":"Feb 7, 2023","L":"02/07/2023","MM-DD":"02-07"},"updated":"2023-03-31T11:45:37.371Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。\n示例 1：\n1234输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;输出：0解释：&quot;sad&quot; 在下标 0 和 6 处匹配。第一个匹配项的下标是 0 ，所以返回 0 。\n示例 2：\n123输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;输出：-1解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。\n提示：\n\n1 &lt;= haystack.length, needle.length &lt;= 104\nhaystack 和 needle 仅由小写英文字符组成\n\n题解\n总结\n思路\nKMP的经典思想就是：当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。\n本篇将以如下顺序来讲解KMP，\n\n什么是KMP\nKMP有什么用\n什么是前缀表\n为什么一定要用前缀表\n如何计算前缀表\n前缀表与next数组\n使用next数组来匹配\n时间复杂度分析\n构造next数组\n使用next数组来做匹配\n前缀表统一减一 C++代码实现\n前缀表（不减一）C++实现\n总结\n\n读完本篇可以顺便把leetcode上28.实现strStr()（现在这道题名字改为了 「28.找出字符串中第一个匹配项的下标」）题目做了。\n什么是KMP\n说到KMP，先说一下KMP这个名字是怎么来的，为什么叫做KMP呢。\n因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP\nKMP有什么用\nKMP主要应用在字符串匹配上。\nKMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。\n所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。\n其实KMP的代码不好理解，一些同学甚至直接把KMP代码的模板背下来。\n没有彻底搞懂，懵懵懂懂就把代码背下来太容易忘了。\n不仅面试的时候可能写不出来，如果面试官问：next数组里的数字表示的是什么，为什么这么表示？\n估计大多数候选人都是懵逼的。\n下面Carl就带大家把KMP的精髓，next数组弄清楚。\n什么是前缀表\n写过KMP的同学，一定都写过next数组，那么这个next数组究竟是个啥呢？\nnext数组就是一个前缀表（prefix table）。\n前缀表有什么作用呢？\n前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。\n为了清楚地了解前缀表的来历，我们来举一个例子：\n要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。\n请记住文本串和模式串的作用，对于理解下文很重要，要不然容易看懵。所以说三遍：\n要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。\n要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。\n要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。\n如动画所示：\n\n动画里，我特意把 子串aa 标记上了，这是有原因的，大家先注意一下，后面还会说到。\n可以看出，文本串中第六个字符b 和 模式串的第六个字符f，不匹配了。如果暴力匹配，发现不匹配，此时就要从头匹配了。\n但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。\n此时就要问了前缀表是如何记录的呢？\n首先要知道前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。\n那么什么是前缀表：记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n最长公共前后缀？\n文章中字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。\n后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。\n正确理解什么是前缀什么是后缀很重要!\n那么网上清一色都说 “kmp 最长公共前后缀” 又是什么回事呢？\n我查了一遍 算法导论 和 算法4里KMP的章节，都没有提到 “最长公共前后缀”这个词，也不知道从哪里来了，我理解是用“最长相等前后缀” 更准确一些。\n因为前缀表要求的就是相同前后缀的长度。\n而最长公共前后缀里面的“公共”，更像是说前缀和后缀公共的长度。这其实并不是前缀表所需要的。\n所以字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 等等…。\n为什么一定要用前缀表\n这就是前缀表，那为啥就能告诉我们 上次匹配的位置，并跳过去呢？\n回顾一下，刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，如图： \n然后就找到了下标2，指向b，继续匹配：如图： \n以下这句话，对于理解为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配 非常重要！\n下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。\n所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。\n很多介绍KMP的文章或者视频并没有把为什么要用前缀表？这个问题说清楚，而是直接默认使用前缀表。\n如何计算前缀表\n接下来就要说一说怎么计算前缀表。\n如图：\n\n长度为前1个字符的子串a，最长相同前后缀的长度为0。（注意字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。）\n\n长度为前2个字符的子串aa，最长相同前后缀的长度为1。\n\n长度为前3个字符的子串aab，最长相同前后缀的长度为0。\n以此类推： 长度为前4个字符的子串aaba，最长相同前后缀的长度为1。 长度为前5个字符的子串aabaa，最长相同前后缀的长度为2。 长度为前6个字符的子串aabaaf，最长相同前后缀的长度为0。\n那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图： \n可以看出模式串与前缀表对应位置的数字表示的就是：下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n再来看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：\n\n找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。\n为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。\n所以要看前一位的 前缀表的数值。\n前一个字符的前缀表的数值是2， 所以把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。\n最后就在文本串中找到了和模式串匹配的子串了。\n前缀表与next数组\n很多KMP算法的时间都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？\nnext数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。\n为什么这么做呢，其实也是很多文章视频没有解释清楚的地方。\n其实这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。\n后面我会提供两种不同的实现代码，大家就明白了。\n使用next数组来匹配\n以下我们以前缀表统一减一之后的next数组来做演示。\n有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。\n注意next数组是新前缀表（旧前缀表统一减一了）。\n匹配过程动画如下：\n\n时间复杂度分析\n其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。\n暴力的解法显而易见是O(n × m)，所以KMP在字符串匹配中极大地提高了搜索的效率。\n为了和力扣题目28.实现strStr保持一致，方便大家理解，以下文章统称haystack为文本串, needle为模式串。\n都知道使用KMP算法，一定要构造next数组。\n构造next数组\n我们定义一个函数getNext来构建next数组，函数参数为指向next数组的指针，和一个字符串。 代码如下：\n1void getNext(int* next, const string&amp; s)\n构造next数组其实就是计算模式串s，前缀表的过程。 主要有如下三步：\n\n初始化\n处理前后缀不相同的情况\n处理前后缀相同的情况\n\n接下来我们详解一下。\n\n初始化：\n\n定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。\n然后还要对next数组进行初始化赋值，如下：\n12int j = -1;next[0] = j;\nj 为什么要初始化为 -1呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。\nnext[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）\n所以初始化next[0] = j 。\n\n处理前后缀不相同的情况\n\n因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。\n所以遍历模式串s的循环下标i 要从 1开始，代码如下：\n1for (int i = 1; i &lt; s.size(); i++) &#123;\n如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。\n怎么回退呢？\nnext[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。\n那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。\n所以，处理前后缀不相同的情况代码如下：\n123while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) &#123; // 前后缀不相同了    j = next[j]; // 向前回退&#125;\n\n处理前后缀相同的情况\n\n如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。\n代码如下：\n1234if (s[i] == s[j + 1]) &#123; // 找到相同的前后缀    j++;&#125;next[i] = j;\n最后整体构建next数组的函数代码如下：\n12345678910111213void getNext(int* next, const string&amp; s)&#123;    int j = -1;    next[0] = j;    for(int i = 1; i &lt; s.size(); i++) &#123; // 注意i从1开始        while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) &#123; // 前后缀不相同了            j = next[j]; // 向前回退        &#125;        if (s[i] == s[j + 1]) &#123; // 找到相同的前后缀            j++;        &#125;        next[i] = j; // 将j（前缀的长度）赋给next[i]    &#125;&#125;\n代码构造next数组的逻辑流程动画如下：\n\n得到了next数组之后，就要用这个来做匹配了。\n使用next数组来做匹配\n在文本串s里 找是否出现过模式串t。\n定义两个下标j 指向模式串起始位置，i指向文本串起始位置。\n那么j初始值依然为-1，为什么呢？ 依然因为next数组里记录的起始位置为-1。\ni就从0开始，遍历文本串，代码如下：\n1for (int i = 0; i &lt; s.size(); i++) \n接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。\n如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。\n代码如下：\n123while(j &gt;= 0 &amp;&amp; s[i] != t[j + 1]) &#123;    j = next[j];&#125;\n如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下：\n123if (s[i] == t[j + 1]) &#123;    j++; // i的增加在for循环里&#125;\n如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。\n本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。\n代码如下：\n123if (j == (t.size() - 1) ) &#123;    return (i - t.size() + 1);&#125;\n那么使用next数组，用模式串匹配文本串的整体代码如下：\n123456789101112int j = -1; // 因为next数组里记录的起始位置为-1for (int i = 0; i &lt; s.size(); i++) &#123; // 注意i就从0开始    while(j &gt;= 0 &amp;&amp; s[i] != t[j + 1]) &#123; // 不匹配        j = next[j]; // j 寻找之前匹配的位置    &#125;    if (s[i] == t[j + 1]) &#123; // 匹配，j和i同时向后移动        j++; // i的增加在for循环里    &#125;    if (j == (t.size() - 1) ) &#123; // 文本串s里出现了模式串t        return (i - t.size() + 1);    &#125;&#125;\n此时所有逻辑的代码都已经写出来了，力扣 28.实现strStr 题目的整体代码如下：\n前缀表统一减一 C++代码实现\n123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public:    void getNext(int* next, const string&amp; s) &#123;        int j = -1;        next[0] = j;        for(int i = 1; i &lt; s.size(); i++) &#123; // 注意i从1开始            while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) &#123; // 前后缀不相同了                j = next[j]; // 向前回退            &#125;            if (s[i] == s[j + 1]) &#123; // 找到相同的前后缀                j++;            &#125;            next[i] = j; // 将j（前缀的长度）赋给next[i]        &#125;    &#125;    int strStr(string haystack, string needle) &#123;        if (needle.size() == 0) &#123;            return 0;        &#125;        int next[needle.size()];        getNext(next, needle);        int j = -1; // // 因为next数组里记录的起始位置为-1        for (int i = 0; i &lt; haystack.size(); i++) &#123; // 注意i就从0开始            while(j &gt;= 0 &amp;&amp; haystack[i] != needle[j + 1]) &#123; // 不匹配                j = next[j]; // j 寻找之前匹配的位置            &#125;            if (haystack[i] == needle[j + 1]) &#123; // 匹配，j和i同时向后移动                j++; // i的增加在for循环里            &#125;            if (j == (needle.size() - 1) ) &#123; // 文本串s里出现了模式串t                return (i - needle.size() + 1);            &#125;        &#125;        return -1;    &#125;&#125;;\n前缀表（不减一）C++实现\n那么前缀表就不减一了，也不右移的，到底行不行呢？\n行！\n我之前说过，这仅仅是KMP算法实现上的问题，如果就直接使用前缀表可以换一种回退方式，找j=next[j-1] 来进行回退。\n主要就是j=next[x]这一步最为关键！\n我给出的getNext的实现为：（前缀表统一减一）\n12345678910111213void getNext(int* next, const string&amp; s) &#123;    int j = -1;    next[0] = j;    for(int i = 1; i &lt; s.size(); i++) &#123; // 注意i从1开始        while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) &#123; // 前后缀不相同了            j = next[j]; // 向前回退        &#125;        if (s[i] == s[j + 1]) &#123; // 找到相同的前后缀            j++;        &#125;        next[i] = j; // 将j（前缀的长度）赋给next[i]    &#125;&#125;\n此时如果输入的模式串为aabaaf，对应的next为-1 0 -1 0 1 -1。\n这里j和next[0]初始化为-1，整个next数组是以 前缀表减一之后的效果来构建的。\n那么前缀表不减一来构建next数组，代码如下：\n12345678910111213void getNext(int* next, const string&amp; s) &#123;    int j = 0;    next[0] = 0;    for(int i = 1; i &lt; s.size(); i++) &#123;        while (j &gt; 0 &amp;&amp; s[i] != s[j]) &#123; // j要保证大于0，因为下面有取j-1作为数组下标的操作            j = next[j - 1]; // 注意这里，是要找前一位的对应的回退位置了        &#125;        if (s[i] == s[j]) &#123;            j++;        &#125;        next[i] = j;    &#125;&#125;\n此时如果输入的模式串为aabaaf，对应的next为 0 1 0 1 2 0，（其实这就是前缀表的数值了）。\n那么用这样的next数组也可以用来做匹配，代码要有所改动。\n实现代码如下：\n123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public:    void getNext(int* next, const string&amp; s) &#123;        int j = 0;        next[0] = 0;        for(int i = 1; i &lt; s.size(); i++) &#123;            while (j &gt; 0 &amp;&amp; s[i] != s[j]) &#123;                j = next[j - 1];            &#125;            if (s[i] == s[j]) &#123;                j++;            &#125;            next[i] = j;        &#125;    &#125;    int strStr(string haystack, string needle) &#123;        if (needle.size() == 0) &#123;            return 0;        &#125;        int next[needle.size()];        getNext(next, needle);        int j = 0;        for (int i = 0; i &lt; haystack.size(); i++) &#123;            while(j &gt; 0 &amp;&amp; haystack[i] != needle[j]) &#123;                j = next[j - 1];            &#125;            if (haystack[i] == needle[j]) &#123;                j++;            &#125;            if (j == needle.size() ) &#123;                return (i - needle.size() + 1);            &#125;        &#125;        return -1;    &#125;&#125;;\n总结\n我们介绍了什么是KMP，KMP可以解决什么问题，然后分析KMP算法里的next数组，知道了next数组就是前缀表，再分析为什么要是前缀表而不是什么其他表。\n接着从给出的模式串中，我们一步一步的推导出了前缀表，得出前缀表无论是统一减一还是不减一得到的next数组仅仅是kmp的实现方式的不同。\n其中还分析了KMP算法的时间复杂度，并且和暴力方法做了对比。\n然后先用前缀表统一减一得到的next数组，求得文本串s里是否出现过模式串t，并给出了具体分析代码。\n又给出了直接用前缀表作为next数组，来做匹配的实现代码。\n可以说把KMP的每一个细微的细节都扣了出来，毫无遮掩的展示给大家了！\n相关题目\n","plink":"https://hs-zhangsan.github.io/leetcode/28-找出字符串中第一个匹配项的下标/"},{"title":"344-反转字符串","date":"2023-02-02T10:44:46.000Z","date_formatted":{"ll":"Feb 2, 2023","L":"02/02/2023","MM-DD":"02-02"},"updated":"2023-03-31T11:45:37.371Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n示例 1：\n12输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]\n示例 2：\n12输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]\n提示：\n\n1 &lt;= s.length &lt;= 105\ns[i] 都是 ASCII 码表中的可打印字符\n\n题解\n解题思路\n\n首先谨记两句话：\n\n如果题目关键的部分直接用库函数就可以解决，不要使用库函数。\n如果库函数仅仅是解题过程中的一小部分，并且你已经很清楚「这个库函数的内部实现原理」的话，可以考虑使用库函数。\n\n\n这道题和 206.反转链表 一样，使用左右指针，初始分别指向字符串的开始和末尾，然后两个指针同时向中间移动，并在过程中交换指针所指的元素即可，区别不过在于数组的实现更简单而已。\n\n代码\n12345678void reverseString(char* s, int sSize)&#123;    int left = 0, right = sSize - 1;    while (left &lt; right) &#123;        int temp = s[left];        s[left++] = s[right];        s[right--] = temp;    &#125;&#125;\n复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(1)\n总结\n好了，放弃哈希表了，开始字符串，直接秒了，一下神清气爽了。\n","plink":"https://hs-zhangsan.github.io/leetcode/344-反转字符串/"},{"title":"349-两个数组的交集","date":"2023-01-31T10:48:57.000Z","date_formatted":{"ll":"Jan 31, 2023","L":"01/31/2023","MM-DD":"01-31"},"updated":"2023-03-31T11:45:37.372Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。\n示例 1：\n12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2]\n示例 2：\n123输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]解释：[4,9] 也是可通过的\n提示：\n\n1 &lt;= nums1.length, nums2.length &lt;= 1000\n0 &lt;= nums1[i], nums2[i] &lt;= 1000\n\n题解\n解题思路\n\n当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。这道题很明显的哈希表题目，用一个哈希表映射第一个数组，再查找第二个数组，如果已经存在就放在结果数组中，注意结果是去重的。\n再来看看哈希表的选择。直接使用set不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的，因此优先使用数组。但是，使用数组来做哈希的题目，是因为题目都限制了数值的大小。而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。因为题目限制数值最多为 1000，所以这道题可以用数组。\n思路很简单，具体看代码。\n\n代码\n12345678910111213141516171819202122/** * Note: The returned array must be malloced, assume caller calls free(). */int* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize)&#123;    int* result = malloc(sizeof(int) * fmin(nums1Size, nums2Size));    int hash[1001] = &#123;0&#125;;    for (int i = 0; i &lt; nums1Size; i++) &#123;        hash[nums1[i]] = 1;    &#125;    int resultSize = 0;    for (int i = 0; i &lt; nums2Size; i++) &#123;        if (hash[nums2[i]] == 1) &#123;            result[resultSize++] = nums2[i];            hash[nums2[i]] = 0;        &#125;    &#125;    *returnSize = resultSize;    return result;&#125;\n复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(1)\n总结\n不想总结。。。\n相关题目\n\n350.两个数组的交集 II\n\n","plink":"https://hs-zhangsan.github.io/leetcode/349-两个数组的交集/"},{"title":"541-反转字符串II","date":"2023-02-03T18:19:59.000Z","date_formatted":{"ll":"Feb 3, 2023","L":"02/03/2023","MM-DD":"02-03"},"updated":"2023-03-31T11:45:37.372Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。\n如果剩余字符少于 k 个，则将剩余字符全部反转。\n如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n示例 1：\n12输入：s = &quot;abcdefg&quot;, k = 2输出：&quot;bacdfeg&quot;\n示例 2：\n12输入：s = &quot;abcd&quot;, k = 2输出：&quot;bacd&quot;\n提示：\n\n1 &lt;= s.length &lt;= 104\ns 仅由小写英文组成\n1 &lt;= k &lt;= 104\n\n题解\n解题思路\n\n这道题对于原题「344.反转字符串」（可参考我的题解：344.反转字符串）来说，只是稍微多了一点限制条件，剩下的和原题一样，正常模拟即可。\n这道的限制只有两点：\n\n每隔 2k 个字符反转前 k 个字符\n剩余字符少于 k 个，则将其全部反转\n\n\n第一点在遍历字符串时每次 +2k 即可；第二点则需要在反转前判断一下剩余字符是否少于 k。没什么好说的，直接上代码。\n\n代码\n123456789101112131415161718char * reverseStr(char * s, int k)&#123;    int len = strlen(s);    for (int i = 0; i &lt; len; i += (2 * k)) &#123;        //判断剩余字符是否少于 k        k = i + k &gt; len ? len - i : k;        int left = i;        int right = i + k - 1;        while (left &lt; right) &#123;            char temp = s[left];            s[left++] = s[right];            s[right--] = temp;        &#125;    &#125;    return s;&#125;\n复杂度分析\n时间复杂度：O(n)​\n空间复杂度：O(1)​\n\n注意，虽然使用了两层循环，但实质上只是遍历了一遍字符串，时间复杂度为 $O(n)$ 而不是 $O(n^2)$。\n\n总结\n赶着去玩，简单做了，题解复制之前的\n","plink":"https://hs-zhangsan.github.io/leetcode/541-反转字符串II/"},{"title":"59-螺旋矩阵II","date":"2023-01-22T09:20:15.000Z","date_formatted":{"ll":"Jan 22, 2023","L":"01/22/2023","MM-DD":"01-22"},"updated":"2023-03-31T11:45:37.373Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n示例 1：\n\n12输入：n = 3输出：[[1,2,3],[8,9,4],[7,6,5]]\n示例 2：\n12输入：n = 1输出：[[1]]\n题解\n解题思路\n\n\n本题并不涉及到什么算法，就是模拟过程，值得注意的一点是，在写代码的过程中一定要遵循循环不变量原则，和 二分查找 中一样，遇到其他情况也是一样。在本题中我统一用左闭右开。\n\n\n具体模拟一下模拟顺时针画矩阵的过程（如图）:\n\n填充上行从左到右\n填充右列从上到下\n填充下行从右到左\n填充左列从下到上\n\n\n\n\n思路很简单，就是从最外圈开始循环，走过一圈后向内圈进一个再继续，直到最后走完。具体看代码，已经详细注释，很容易就能看明白。\n\n\n代码\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */int** generateMatrix(int n, int* returnSize, int** returnColumnSizes)&#123;    //先申请数组并申请空间，其他语言可能不用    int** result = malloc(sizeof(int*) * n);    for (int i = 0; i &lt; n; i++) &#123;        result[i] = malloc(sizeof(int) * n);    &#125;        int loop = n / 2;\t//用来确定循环的圈数    int offset = 1;\t//用来确定每条边遍历的长度    int count = 1;\t//用来给矩阵赋值    int startX = 0, startY = 0;\t//用来确定每个圈开始循环的起始位置    //若 n 为奇数，则需单独给最中间的位置赋值    if (n % 2) &#123;        result[loop][loop] = n * n;    &#125;    //下面就是这道题的核心代码，模拟循环的过程    while (loop--) &#123;        int i = startX;        int j = startY;        //下面四个循环就是模拟每圈的四个边转了一圈，都是左闭右开        //模拟上行从左到右        while (j &lt; n - offset) &#123;            result[i][j++] = count++;        &#125;        //模拟右列从上到下        while (i &lt; n - offset) &#123;            result[i++][j] = count++;        &#125;        //模拟下行从右到左        while (j &gt; startY) &#123;            result[i][j--] = count++;        &#125;        //模拟左列从下到上        while (i &gt; startY) &#123;            result[i--][j] = count++;        &#125;        //每圈结束之后，起始位置各自加一。例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)        startX++;        startY++;        //用来控制每圈每条边的遍历长度，每走一圈就加一。        offset++;    &#125;    *returnSize = n;    *returnColumnSizes = malloc(sizeof(int) * n);    for (int i = 0; i &lt; n; i++) &#123;        (*returnColumnSizes)[i] = n;    &#125;    return result;&#125;\n总结\n还是比较难，也不是一眼就看懂了，之前做过两遍，但还是不熟。\n相关题目\n\n54.螺旋矩阵\n剑指Offer 29.顺时针打印矩阵\n\n","plink":"https://hs-zhangsan.github.io/leetcode/59-螺旋矩阵II/"},{"title":"704-二分查找","date":"2023-01-17T19:56:44.000Z","date_formatted":{"ll":"Jan 17, 2023","L":"01/17/2023","MM-DD":"01-17"},"updated":"2023-03-31T11:45:37.373Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例 1:\n123输入: nums = [-1,0,3,5,9,12], target = 9     输出: 4       解释: 9 出现在 nums 中并且下标为 4     \n示例 2:\n123输入: nums = [-1,0,3,5,9,12], target = 2     输出: -1        解释: 2 不存在 nums 中因此返回 -1        \n提示：\n\n你可以假设 nums 中的所有元素是不重复的。\nn 将在 [1, 10000]之间。\nnums 的每个元素都将在 [-9999, 9999]之间。\n\n题解\n解题思路\n\n二分查找有两个前提，第一是**「有序排列」，第二是「无重复元素」**。当满足以上两点的时候就可以考虑是不是可以使用二分法了。（当然这道题题目已经说了是二分查找）\n二分法的逻辑较简单，需要注意的就是 边界条件 ，例如循环判断条件到底是 left &lt; right 还是 left &lt;= right ？或者 right = middle 还是 right = middle - 1？\n这里需要明确区间的定义，二分法的区间定义一般分为两种，一是左闭右闭 [left, right] ，另一种是左闭右开 [left, right) 。\n以数组 [2, 3, 4, 5, 8, 9] 为例，一共 6 个元素，对应下标为 0-5，当区间定义为左闭右闭时，right 初始化为 5，对应的代码为 left &lt;= right 和 right = middle - 1 ；当区间定义为左闭右开时，right 初始化为 6 （由于元素 nums[6] 无意义，所以边界 6 为开区间） ，对应的代码为 left &lt; right 和 right = middle 。\n两种定义方法选择一种固定使用就好，个人建议左闭右闭，因为右边界有意义，返回结果比较清晰直观。当然，适合自己就好。\n\n代码\n1234567891011121314int search(int* nums, int numsSize, int target)&#123;    int left = 0, right = numsSize - 1;    while (left &lt;= right) &#123;        int middle = left + ((right - left) / 2);        if (nums[middle] &gt; target) &#123;            right = middle - 1;        &#125; else if (nums[middle] &lt; target) &#123;            left = middle + 1;        &#125; else &#123;            return middle;        &#125;    &#125;    return -1;&#125;\n复杂度分析\n时间复杂度：O(logN)\n空间复杂度：O(N)\nPS：若题目要求时间复杂度带 logN ，一般要用到二分法。\n总结\n二分查找比较简单，但是我好久没做题，今天刚上手结果就把二分查找的错误都犯了，具体就是忘了二分查找的关键，即边界条件，由此搞错了循环条件的小于还是小于等于，还有没找到时是等于 middle 还是 middle-1。\n还是不熟悉，太久没做连最基础的二分查找都忘了，一时不知该说什么。\n相关题目\n\n35.搜索插入位置\n34.在排序数组中查找元素的第一个和最后一个位置\n69.x 的平方根\n367.有效的完全平方数\n\n","plink":"https://hs-zhangsan.github.io/leetcode/704-二分查找/"},{"title":"707-设计链表","date":"2023-01-24T10:00:20.000Z","date_formatted":{"ll":"Jan 24, 2023","L":"01/24/2023","MM-DD":"01-24"},"updated":"2023-03-31T11:45:37.374Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。\n在链表类中实现这些功能：\n\nget(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。\naddAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。\naddAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。\naddAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\ndeleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。\n\n示例：\n1234567MyLinkedList linkedList = new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3linkedList.get(1);            //返回2linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3linkedList.get(1);            //返回3\n提示：\n\n0 &lt;= index, val &lt;= 1000\n请不要使用内置的 LinkedList 库。\nget, addAtHead, addAtTail, addAtIndex 和 deleteAtIndex 的操作次数不超过 2000。\n\n题解\n解题思路\n\n首先还是那句话，链表类题目无脑用虚拟头结点。在这道题中，由于要对用第一个结点进行操作，给出的指针又直接指向第一个结点，所以不用哑结点也没法操作。\n这道题涵盖了链表常见的所有操作，对于理解链表非常有帮助。所有操作的逻辑很简单，如果想不明白不要去硬想，找张纸画一画很容易就理解了。重点是具体的代码实现，可以对着我的代码理解一下，记一记就好了。\n在做这道题的时候我遇到了一个问题，在 deleteAtIndex(index) 操作中，如果我写成 curr-&gt;next = curr-&gt;next-&gt;next ，就会报如下的错误，而改成 curr-&gt;next = temp-&gt;next 就没有问题，也搞不懂为什么。\n\n1error: dereferencing pointer to incomplete type &#x27;struct MyLinkedList&#x27; [solution.c]\n代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//定义链表结点typedef struct &#123;    int val;    struct MyLinkedList* next;&#125; MyLinkedList;//初始化链表MyLinkedList* myLinkedListCreate() &#123;    //这里的头结点是虚拟头结点（哑结点）    MyLinkedList* head = malloc(sizeof(MyLinkedList));    head-&gt;next = NULL;    return head;&#125;//返回第 index 个结点的数值int myLinkedListGet(MyLinkedList* obj, int index) &#123;    MyLinkedList* curr = obj-&gt;next;    for (int i = 0; curr; i++) &#123;        if (i == index) &#123;            return curr-&gt;val;        &#125; else &#123;            curr = curr-&gt;next;        &#125;    &#125;    return -1;&#125;//在链表最前面插入一个节点结点void myLinkedListAddAtHead(MyLinkedList* obj, int val) &#123;    MyLinkedList* head = malloc(sizeof(MyLinkedList));    head-&gt;val = val;    head-&gt;next = obj-&gt;next;    obj-&gt;next = head;&#125;//在链表最后面插入一个结点void myLinkedListAddAtTail(MyLinkedList* obj, int val) &#123;    MyLinkedList* curr = obj;    while (curr-&gt;next) &#123;        curr = curr-&gt;next;    &#125;    MyLinkedList* tail = malloc(sizeof(MyLinkedList));    tail-&gt;val = val;    tail-&gt;next = NULL;    curr-&gt;next = tail;&#125;//在链表第 index 个节点之前插入一个结点void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) &#123;     MyLinkedList* curr = obj;    for (int i = 0; curr; i++) &#123;        if (i == index) &#123;            MyLinkedList* temp = malloc(sizeof(MyLinkedList));            temp-&gt;val = val;            temp-&gt;next = curr-&gt;next;            curr-&gt;next = temp;        &#125; else &#123;            curr = curr-&gt;next;        &#125;    &#125;&#125;//删除第 index 个结点void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) &#123;    MyLinkedList* curr = obj;    for (int i = 0; curr; i++) &#123;        if (i == index) &#123;            MyLinkedList* temp = curr-&gt;next;            if (temp) &#123;                //下面这行代码如果改成 curr-&gt;next = curr-&gt;next-&gt;next 就会报错                curr-&gt;next = temp-&gt;next;                free(temp);            &#125;        &#125; else &#123;            curr = curr-&gt;next;        &#125;    &#125;&#125;//删除链表void myLinkedListFree(MyLinkedList* obj) &#123;    while (obj) &#123;        MyLinkedList* temp = obj;        obj = obj-&gt;next;        free(temp);    &#125;&#125;/** * Your MyLinkedList struct will be instantiated and called as such: * MyLinkedList* obj = myLinkedListCreate(); * int param_1 = myLinkedListGet(obj, index);  * myLinkedListAddAtHead(obj, val);  * myLinkedListAddAtTail(obj, val);  * myLinkedListAddAtIndex(obj, index, val);  * myLinkedListDeleteAtIndex(obj, index);  * myLinkedListFree(obj);*/\n总结\n基本都能写出来，但还是磕磕碰碰，免不了要看题解。\n","plink":"https://hs-zhangsan.github.io/leetcode/707-设计链表/"},{"title":"977-有序数组的平方","date":"2023-01-20T09:05:15.000Z","date_formatted":{"ll":"Jan 20, 2023","L":"01/20/2023","MM-DD":"01-20"},"updated":"2023-03-31T11:45:37.374Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]\n示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]\n题解\n解题思路\n\n我们很容易想到这道题的暴力解法就是给数组每个元素平方后再进行排序，时间复杂度为O(NlogN)。\n然而，由于数组是有序的，即使负数平方后可能会成为最大数，但数组最大值都在数组两端，不是最左边就是最右边，因此可以考虑双指针法了，左右指针分别指向起始位置和终止位置。然后重新使用一个数组 result 用来存放结果，索引 index 指向 result 数组的终止位置。\n\n若 nums[left] * nums[left] &gt; nums[right] * nums[right] ，\n则 result[index--] = nums[left] * nums[left++]\n若 nums[left] * nums[left] &lt;= nums[right] * nums[right] ，\n则 result[index--] = nums[right] * nums[right--]\n\n\n思路清晰明了，想通后不难写出以下代码：\n\n代码\n123456789101112131415161718/** * Note: The returned array must be malloced, assume caller calls free(). */int* sortedSquares(int* nums, int numsSize, int* returnSize)&#123;    int* result = malloc(sizeof(int) * numsSize);    int left = 0, right = numsSize - 1, index = numsSize - 1;    while (left &lt;= right) &#123; //判断条件也可以改成 index &gt;= 0        if (nums[left] * nums[left] &gt; nums[right] * nums[right]) &#123;            result[index--] = nums[left] * nums[left++];        &#125; else &#123;            result[index--] = nums[right] * nums[right--];        &#125;    &#125;    *returnSize = numsSize;    return result;&#125;\n复杂度分析\n时间复杂度：O(N)\n空间复杂度：O(N)\n总结\n想到了双指针但是想出来具体怎么写，看了一眼后也就明白了，就是忘了。\n","plink":"https://hs-zhangsan.github.io/leetcode/977-有序数组的平方/"},{"title":"leetcode","date":"2023-01-18T00:00:00.000Z","date_formatted":{"ll":"Jan 18, 2023","L":"01/18/2023","MM-DD":"01-18"},"updated":"2023-03-31T03:45:37.375Z","content":"简体中文 ｜ English\n看中文还不够么？。。\n","plink":"https://hs-zhangsan.github.io/leetcode/index-en/"},{"title":"leetcode","date":"2023-01-18T00:00:00.000Z","date_formatted":{"ll":"Jan 18, 2023","L":"01/18/2023","MM-DD":"01-18"},"updated":"2023-03-31T03:45:37.375Z","content":"简体中文 ｜ English\n*写在前面\n先声明，本人是跟着代码随想录(https://programmercarl.com)刷的，如有雷同，不是巧合。\n然后剩下好多想说的话懒得写了，后面想写了再补上。\n也可以直接在主页或者右下角搜索具体题目。\n\n2023-01-23\n今天翻看之前在力扣上写的题解 203.移除链表元素，发现果然还是被说直接复制代码随想录的，所以我这次开始就说明了。另外，退一步讲，知识这东西学到手上就是自己的，我写的题解也都是看着代码随想录看懂之后再自己记录下来的。虽然说，你只要跟着别人学的，其他人直接说你是抄的你也没办法，但是，抄这类字眼总会让我伤心，哪怕这只是我矫情。反正我是不承认我抄题解的，读书人的事，那叫抄吗？\n数组\n\n数组理论基础\n二分查找\n移除元素\n有序数组的平方\n长度最小的子数组\n螺旋矩阵II\n数组总结篇\n\n链表\n\n链表理论基础\n移除链表元素\n设计链表\n翻转链表\n两两交换链表中的节点\n删除链表的倒数第N个节点\n链表相交\n环形链表II\n链表总结篇\n\n哈希表\n\n哈希表理论基础\n有效的字母异位词\n两个数组的交集\n快乐数\n两数之和\n四数相加II\n赎金信\n三数之和\n四数之和\n总结篇\n\n字符串\n\n反转字符串\n反转字符串II\n替换空格\n 反转字符串里的单词\n左旋转字符串\n找出字符串中第一个匹配项的下标\n重复的子字符串\n总结篇\n\n双指针法\n栈与队列\n二叉树\n回溯算法\n贪心算法\n动态规划\n单调栈\n","plink":"https://hs-zhangsan.github.io/leetcode/"},{"title":"剑指Offer05-替换空格","date":"2023-02-04T14:01:10.000Z","date_formatted":{"ll":"Feb 4, 2023","L":"02/04/2023","MM-DD":"02-04"},"updated":"2023-03-31T11:45:37.375Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。\n示例 1：\n12输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot;\n限制：\n\n0 &lt;= s 的长度 &lt;= 10000\n\n题解\n解题思路\n\n首先说明一点，有些语言是可以直接给已存在数组扩容的（比如 C++ 可以使用 resize() 给数组扩容），这样的话做这道题就不用再使用一个新的数组保存结果，从而将空间复杂度从 $O(n)$ 降为 $O(1)$，而 C 语言是不能直接给数组扩容的。当然这影响不大，主要是理解算法，追求极致的时间复杂度。\n具体地，先统计空格的数量 count，这样就确定了新数组的长度为 len + 2 * count 了（len 为原数组的长度，C 语言的话新数组长度还要再加一，因为 C 语言字符串结尾还有 ‘\\0’ 需要一个 char 类型的空间），然后申请新的数组。\n新数组申请好之后，使用双指针，让 i 和 j 分别指向原数组和新数组的开始，然后同时向后移动，在遍历原数组的过程中填充新数组，当遇到空格时将 ‘%‘、’2‘、’0‘ 三个字符分别赋值给 j 所指的元素及其后两个元素，并将 j 额外加二即可。\n注意，若果是直接修改原数组的话，就必须从后向前填充，从前向后填充就是 $O(n^2)$ 的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。\n其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。 这么做有两个好处：\n\n不用申请新数组。\n从后向前填充元素，避免了从前先后填充元素要来的每次添加元素都要将添加元素之后的所有元素向后移动。\n\n\n\n代码\n12345678910111213141516171819202122232425char* replaceSpace(char* s)&#123;    int len = strlen(s);    int count = 0;    for (int i = 0; i &lt; len; i++) &#123;        if (s[i] == &#x27; &#x27;) &#123;            count++;        &#125;    &#125;    int newLen = len + 2 * count;    char* result = malloc(sizeof(char) * newLen + 1);    for (int i = 0, j = 0; i &lt; len; i++, j++) &#123;        if (s[i] == &#x27; &#x27;) &#123;            result[j] = &#x27;%&#x27;;            result[j + 1] = &#x27;2&#x27;;            result[j + 2] = &#x27;0&#x27;;            j += 2;        &#125; else &#123;            result[j] = s[i];        &#125;    &#125;    result[newLen] = &#x27;\\0&#x27;;    return result;&#125;\n复杂度分析\n时间复杂度：O(n)​\n空间复杂度：O(n)\n总结\n直接秒了，没什么好说的。\n看了一下之前的题解，真的好稚嫩啊，罗里吧嗦的，也懒得再写了，直接抄过来。\n","plink":"https://hs-zhangsan.github.io/leetcode/剑指Offer05-替换空格/"},{"title":"剑指Offer58-II-左旋转字符串","date":"2023-02-06T14:30:30.000Z","date_formatted":{"ll":"Feb 6, 2023","L":"02/06/2023","MM-DD":"02-06"},"updated":"2023-03-31T11:45:37.376Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。\n示例 1：\n12输入: s = &quot;abcdefg&quot;, k = 2输出: &quot;cdefgab&quot;\n示例 2：\n12输入: s = &quot;lrloseumgh&quot;, k = 6输出: &quot;umghlrlose&quot;\n限制：\n\n1 &lt;= k &lt; s.length &lt;= 10000\n\n题解\n解题思路\n\n最直接的思路，申请一个数组然后按要求填入字符，没什么好说的这样时间复杂度 O(n)，空间复杂度 O(n)。\n\n12345678910111213char* reverseLeftWords(char* s, int n)&#123;    int len = strlen(s);    char* result = malloc(sizeof(char) * len + 1);    int count = 0;    for (int i = n; i &lt; len; i++) &#123;        result[count++] = s[i];    &#125;    for (int i = 0; i &lt; n; i++) &#123;        result[count++] = s[i];    &#125;    result[count] = &#x27;\\0&#x27;;    return result;&#125;\n\n\n我们来上点难度，不使用额外的数组，直接在原字符串上操作。\n\n\n之前我们在 151.反转字符串里的单词 中讲过，使用 整体反转+局部反转 就可以实现「反转单词顺序」的目的。这道题也是一样的思路。\n\n\n具体步骤如下：\n\n反转前 n 个字符\n反转 n 到末尾的字符\n反转整个字符串\n\n\n\n这样就可以得到左旋 n 的目的，而不用申请新的字符串，完全在原字符串上操作，空间复杂度降为 O(1)。\n\n\n代码\n123456789101112131415161718char* reverse(char* s, int start, int end) &#123;    while (start &lt; end) &#123;        char temp = s[start];        s[start++] = s[end];        s[end--] = temp;    &#125;    return s;&#125;char* reverseLeftWords(char* s, int n)&#123;    int len = strlen(s);    //反转前 n 个字符    s = reverse(s, 0, n - 1);    //反转 k 到末尾的字符    s = reverse(s, n, len - 1);    //反转整个字符串    s = reverse(s, 0, len - 1);    return s;&#125;\n总结\n上来直接秒了，然后想着直接操作原字符串怎么做，没想出来，看了一眼题解，呵，我是傻逼。\n","plink":"https://hs-zhangsan.github.io/leetcode/剑指Offer58-II-左旋转字符串/"},{"title":"哈希表理论基础","date":"2023-01-30T09:54:11.000Z","date_formatted":{"ll":"Jan 30, 2023","L":"01/30/2023","MM-DD":"01-30"},"updated":"2023-03-31T11:45:37.376Z","content":"【目录】\n哈希表这块是我一直搞不太懂的地方，理论很简单也能理解，但是实际操作起来只想哭，后面才意识到这是因为我用的 C 的原因，需要自己手搓哈希表，而其它语言都有哈希表可以直接用。\n说到这个，之前被朋友说过一句话，「用 C 刷题的都是大佬」，我才知道是因为用 C 刷题本身就很难，讲道理，这给了我不少自信，我觉得自己又行了。这次一鼓作气搞定 C 语言的哈希表，不就是每次使用前先造轮子么，大不了直接背过每次在抄一遍。\n下面是卡子哥的哈希表理论基础，原文链接：https://programmercarl.com/哈希表理论基础.html\n\n哈希表\n首先什么是 哈希表，哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指hash table就可以了）。\n\n哈希表是根据关键码的值而直接进行访问的数据结构。\n\n这么这官方的解释可能有点懵，其实直白来讲其实数组就是一张哈希表。\n哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：\n\n那么哈希表能解决什么问题呢，一般哈希表都是用来快速判断一个元素是否出现集合里。\n例如要查询一个名字是否在这所学校里。\n要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。\n我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。\n将学生姓名映射到哈希表上就涉及到了hash function ，也就是哈希函数。\n哈希函数\n哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。\n哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。\n\n如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？\n此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。\n此时问题又来了，哈希表我们刚刚说过，就是一个数组。\n如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。\n接下来哈希碰撞登场\n哈希碰撞\n如图所示，小李和小王都映射到了索引下标 1 的位置，这一现象叫做哈希碰撞。\n\n一般哈希碰撞有两种解决方法， 拉链法和线性探测法。\n拉链法\n刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了\n\n（数据规模是dataSize， 哈希表的大小为tableSize）\n其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。\n线性探测法\n使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。\n例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：\n\n其实关于哈希碰撞还有非常多的细节，感兴趣的同学可以再好好研究一下，这里我就不再赘述了。\n常见的三种哈希结构\n当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。\n\n数组\nset （集合）\nmap(映射)\n\n这里数组就没啥可说的了，我们来看一下set。\n在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：\n\n\n集合\n底层实现\n是否有序\n数值是否可以重复\n能否更改数值\n查询效率\n增删效率\n\n\n\n\nstd::set\n红黑树\n有序\n否\n否\nO(log n)\nO(log n)\n\n\nstd::multiset\n红黑树\n有序\n是\n否\nO(logn)\nO(logn)\n\n\nstd::unordered_set\n哈希表\n无序\n否\n否\nO(1)\nO(1)\n\n\nstd::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。\n\n\n映射\n底层实现\n是否有序\n数值是否可以重复\n能否更改数值\n查询效率\n增删效率\n\n\n\n\nstd::map\n红黑树\nkey有序\nkey不可重复\nkey不可修改\nO(logn)\nO(logn)\n\n\nstd::multimap\n红黑树\nkey有序\nkey可重复\nkey不可修改\nO(log n)\nO(log n)\n\n\nstd::unordered_map\n哈希表\nkey无序\nkey不可重复\nkey不可修改\nO(1)\nO(1)\n\n\nstd::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。\n当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。\n那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。\n其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。\n虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。\n这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？\n实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。\n\n总结\n总结一下，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。\n但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。\n如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！\n","plink":"https://hs-zhangsan.github.io/leetcode/哈希表理论基础/"},{"title":"数组总结篇","date":"2023-01-22T11:36:07.000Z","date_formatted":{"ll":"Jan 22, 2023","L":"01/22/2023","MM-DD":"01-22"},"updated":"2023-04-10T16:01:52.490Z","content":"【目录】\n还是直接搬运卡子哥的总结，原文链接 https://programmercarl.com/数组总结篇.html\n\n数组理论基础\n数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力\n也就是说，想法很简单，但实现起来 可能就不是那么回事了。\n首先要知道数组在内存中的存储方式，这样才能真正理解数组相关的面试题\n数组是存放在连续内存空间上的相同类型数据的集合。\n数组可以方便的通过下标索引的方式获取到下标下对应的数据。\n举一个字符数组的例子，如图所示：\n\n需要两点注意的是\n\n数组下标都是从0开始的。\n数组内存空间的地址是连续的\n\n正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。\n例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：\n\n而且大家如果使用C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。\n数组的元素是不能删的，只能覆盖。\n那么二维数组直接上图，大家应该就知道怎么回事了\n\n那么二维数组在内存的空间地址是连续的么？\n我们来举一个Java的例子，例如： int[][] rating = new int[3][4]; ， 这个二维数组在内存空间可不是一个 3*4 的连续地址空间\n看了下图，就应该明白了：\n\n所以Java的二维数组在内存中不是 3\\*4 的连续地址空间，而是四条连续的地址空间组成！\n数组的经典题目\n在面试中，数组是必考的基础数据结构。\n其实数组的题目在思想上一般比较简单的，但是如果想高效，并不容易。\n我们之前一共讲解了四道经典数组题目，每一道题目都代表一个类型，一种思想。\n二分法\n数组：每次遇到二分法，都是一看就会，一写就废\n这道题目呢，考察数组的基本操作，思路很简单，但是通过率在简单题里并不高，不要轻敌。\n可以使用暴力解法，通过这道题目，如果追求更优的算法，建议试一试用二分法，来解决这道题目\n\n暴力解法时间复杂度：O(n)\n二分法时间复杂度：O(logn)\n\n在这道题目中我们讲到了循环不变量原则，只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。\n二分法是算法面试中的常考题，建议通过这道题目，锻炼自己手撕二分的能力。\n双指针法\n\n数组：就移除个元素很难么？\n\n双指针法（快慢指针法）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n\n暴力解法时间复杂度：O(n^2)\n双指针时间复杂度：O(n)\n\n这道题目迷惑了不少同学，纠结于数组中的元素为什么不能删除，主要是因为以下两点：\n\n数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。\nC++中vector和array的区别一定要弄清楚，vector的底层实现是array，封装后使用更友好。\n\n双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组和链表操作的面试题，都使用双指针法。\n滑动窗口\n\n数组：滑动窗口拯救了你\n\n本题介绍了数组操作中的另一个重要思想：滑动窗口。\n\n暴力解法时间复杂度：O(n^2)\n滑动窗口时间复杂度：O(n)\n\n本题中，主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的，从而得出长度最小的符合条件的长度。\n滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。\n如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。\n模拟行为\n\n数组：这个循环可以转懵很多人！\n\n模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，十分考察大家对代码的掌控能力。\n在这道题目中，我们再一次介绍到了循环不变量原则，其实这也是写程序中的重要原则。\n相信大家有遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，拆了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实真正解决题目的代码都是简洁的，或者有原则性的，大家可以在这道题目中体会到这一点。\n总结\n\n这个图是 代码随想录知识星球成员：海螺人，所画，总结的非常好，分享给大家。\n从二分法到双指针，从滑动窗口到螺旋矩阵，相信如果大家真的认真做了「代码随想录」每日推荐的题目，定会有所收获。\n推荐的题目即使大家之前做过了，再读一遍文章，也会帮助你提炼出解题的精髓所在。\n","plink":"https://hs-zhangsan.github.io/leetcode/数组总结篇/"},{"title":"数组理论基础","date":"2023-01-18T09:59:35.000Z","date_formatted":{"ll":"Jan 18, 2023","L":"01/18/2023","MM-DD":"01-18"},"updated":"2023-03-31T11:45:37.377Z","content":"【目录】\n数组比较简单，没什么好说的，为了系统一点也写上，这里直接把 Carl 的搬运过来了，原文链接 https://programmercarl.com/数组理论基础.html\n\n数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力\n也就是说，想法很简单，但实现起来 可能就不是那么回事了。\n首先要知道数组在内存中的存储方式，这样才能真正理解数组相关的面试题\n数组是存放在连续内存空间上的相同类型数据的集合。\n数组可以方便的通过下标索引的方式获取到下标下对应的数据。\n举一个字符数组的例子，如图所示：\n\n需要两点注意的是\n\n数组下标都是从0开始的。\n数组内存空间的地址是连续的\n\n正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。\n例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：\n\n而且大家如果使用C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。\n数组的元素是不能删的，只能覆盖。\n那么二维数组直接上图，大家应该就知道怎么回事了\n\n那么二维数组在内存的空间地址是连续的么？\n不同编程语言的内存管理是不一样的，以C++为例，在C++中二维数组是连续分布的。\n我们来做一个实验，C++测试代码如下：\n123456789101112void test_arr() &#123;    int array[2][3] = &#123;\t\t&#123;0, 1, 2&#125;,\t\t&#123;3, 4, 5&#125;    &#125;;    cout &lt;&lt; &amp;array[0][0] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[0][1] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[0][2] &lt;&lt; endl;    cout &lt;&lt; &amp;array[1][0] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[1][1] &lt;&lt; &quot; &quot; &lt;&lt; &amp;array[1][2] &lt;&lt; endl;&#125;int main() &#123;    test_arr();&#125;\n测试地址为\n120x7ffee4065820 0x7ffee4065824 0x7ffee40658280x7ffee406582c 0x7ffee4065830 0x7ffee4065834\n注意地址为16进制，可以看出二维数组地址是连续一条线的。\n一些录友可能看不懂内存地址，我就简单介绍一下， 0x7ffee4065820 与 0x7ffee4065824 差了一个4，就是4个字节，因为这是一个int型的数组，所以两个相邻数组元素地址差4个字节。\n0x7ffee4065828 与 0x7ffee406582c 也是差了4个字节，在16进制里8 + 4 = c，c就是12。\n如图：\n\n所以可以看出在C++中二维数组在地址空间上是连续的。\n像Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。\n所以看不到每个元素的地址情况，这里我以Java为例，也做一个实验。\n1234567public static void test_arr() &#123;    int[][] arr = &#123;&#123;1, 2, 3&#125;, &#123;3, 4, 5&#125;, &#123;6, 7, 8&#125;, &#123;9,9,9&#125;&#125;;    System.out.println(arr[0]);    System.out.println(arr[1]);    System.out.println(arr[2]);    System.out.println(arr[3]);&#125;\n输出的地址为：\n1234[I@7852e922[I@4e25154f[I@70dea4e[I@5c647e05\n这里的数值也是16进制，这不是真正的地址，而是经过处理过后的数值了，我们也可以看出，二维数组的每一行头结点的地址是没有规则的，更谈不上连续。\n所以Java的二维数组可能是如下排列的方式：\n\n这里面试中数组相关的理论知识就介绍完了。\n","plink":"https://hs-zhangsan.github.io/leetcode/数组理论基础/"},{"title":"链表总结篇","date":"2023-01-29T11:43:04.000Z","date_formatted":{"ll":"Jan 29, 2023","L":"01/29/2023","MM-DD":"01-29"},"updated":"2023-03-31T11:45:37.378Z","content":"【目录】\n原文链接：https://programmercarl.com/链表总结篇.html\n\n链表的理论基础\n在这篇文章关于链表，你该了解这些！中，介绍了如下几点：\n\n链表的种类主要为：单链表，双链表，循环链表\n链表的存储方式：链表的节点在内存中是分散存储的，通过指针连在一起。\n链表是如何进行增删改查的。\n数组和链表在不同场景下的性能分析。\n\n可以说把链表基础的知识都概括了，但又不像教科书那样的繁琐。\n链表经典题目\n虚拟头结点\n在链表：听说用虚拟头节点会方便很多？ 中，我们讲解了链表操作中一个非常总要的技巧：虚拟头节点。\n链表的一大问题就是操作当前节点必须要找前一个节点才能操作。这就造成了，头结点的尴尬，因为头结点没有前一个节点了。\n每次对应头结点的情况都要单独处理，所以使用虚拟头结点的技巧，就可以解决这个问题。\n在链表：听说用虚拟头节点会方便很多？中，我给出了用虚拟头结点和没用虚拟头结点的代码，大家对比一下就会发现，使用虚拟头结点的好处。\n链表的基本操作\n在链表：一道题目考察了常见的五个操作！中，我们通设计链表把链表常见的五个操作练习了一遍。\n这是练习链表基础操作的非常好的一道题目，考察了：\n\n获取链表第index个节点的数值\n在链表的最前面插入一个节点\n在链表的最后面插入一个节点\n在链表第index个节点前面插入一个节点\n删除链表的第index个节点的数值\n\n可以说把这道题目做了，链表基本操作就OK了，再也不用担心链表增删改查整不明白了。\n这里我依然使用了虚拟头结点的技巧，大家复习的时候，可以去看一下代码。\n反转链表\n在链表：听说过两天反转链表又写不出来了？中，讲解了如何反转链表。\n因为反转链表的代码相对简单，有的同学可能直接背下来了，但一写还是容易出问题。\n反转链表是面试中高频题目，很考察面试者对链表操作的熟练程度。\n我在文章中，给出了两种反转的方式，迭代法和递归法。\n建议大家先学透迭代法，然后再看递归法，因为递归法比较绕，如果迭代还写不明白，递归基本也写不明白了。\n可以先通过迭代法，彻底弄清楚链表反转的过程！\n删除倒数第N个节点\n在链表：删除链表倒数第N个节点，怎么删？中我们结合虚拟头结点 和 双指针法来移除链表倒数第N个节点。\n链表相交\n链表：链表相交使用双指针来找到两个链表的交点（引用完全相同，即：内存地址完全相同的交点）\n环形链表\n在链表：环找到了，那入口呢？ 中，讲解了在链表如何找环，以及如何找环的入口位置。\n这道题目可以说是链表的比较难的题目了。 但代码却十分简洁，主要在于一些数学证明。\n总结\n\n这个图是 代码随想录知识星球成员：海螺人，所画，总结的非常好，分享给大家。\n考察链表的操作其实就是考察指针的操作，是面试中的常见类型。\n链表篇中开头介绍链表理论知识 ，然后分别通过经典题目介绍了如下知识点：\n\n关于链表，你该了解这些！\n虚拟头结点的技巧\n链表的增删改查\n反转一个链表\n删除倒数第N个节点\n链表相交\n有否环形，以及环的入口\n\n","plink":"https://hs-zhangsan.github.io/leetcode/链表总结篇/"},{"title":"链表理论基础","date":"2023-01-23T10:06:36.000Z","date_formatted":{"ll":"Jan 23, 2023","L":"01/23/2023","MM-DD":"01-23"},"updated":"2023-03-31T11:45:37.378Z","content":"【目录】\n原链接 https://programmercarl.com/链表理论基础.html\n\n关于链表，你该了解这些！\n什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。\n链表的入口节点称为链表的头结点也就是head。\n如图所示： \n链表的类型\n接下来说一下链表的几种类型:\n单链表\n刚刚说的就是单链表。\n双链表\n单链表中的指针域只能指向节点的下一个节点。\n双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。\n双链表 既可以向前查询也可以向后查询。\n如图所示： \n循环链表\n循环链表，顾名思义，就是链表首尾相连。\n循环链表可以用来解决约瑟夫环问题。\n\n链表的存储方式\n了解完链表的类型，再来说一说链表在内存中的存储方式。\n数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。\n链表是通过指针域的指针链接在内存中各个节点。\n所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。\n如图所示：\n\n这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。\n链表的定义\n接下来说一说链表的定义。\n链表节点的定义，很多同学在面试的时候都写不好。\n这是因为平时在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。\n而在面试的时候，一旦要自己手写链表，就写的错漏百出。\n这里我给出C/C++的定义链表节点方式，如下所示：\n123456// 单链表struct ListNode &#123;    int val;  // 节点上存储的元素    ListNode *next;  // 指向下一个节点的指针    ListNode(int x) : val(x), next(NULL) &#123;&#125;  // 节点的构造函数&#125;;\n有同学说了，我不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。\n但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：\n通过自己定义构造函数初始化节点：\n1ListNode* head = new ListNode(5);\n使用默认构造函数初始化节点：\n12ListNode* head = new ListNode();head-&gt;val = 5;\n所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！\n链表的操作\n删除节点\n删除D节点，如图所示：\n\n只要将C节点的next指针 指向E节点就可以了。\n那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。\n是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存。\n其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。\n添加节点\n如图所示：\n\n可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。\n但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。\n性能分析\n再把链表的特性和数组的特性进行一个对比，如图所示：\n\n数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。\n链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。\n相信大家已经对链表足够的了解，后面我会讲解关于链表的高频面试题目，我们下期见！\n","plink":"https://hs-zhangsan.github.io/leetcode/链表理论基础/"},{"title":"面试题02.07","date":"2023-01-28T11:01:22.000Z","date_formatted":{"ll":"Jan 28, 2023","L":"01/28/2023","MM-DD":"01-28"},"updated":"2023-03-31T11:45:37.379Z","content":"【目录】 | 力扣链接 | 力扣题解链接\n题目描述\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n注意，函数返回结果后，链表必须 保持其原始结构 。\n示例 1：\n\n12345输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at &#x27;8&#x27;解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n示例 2：\n\n12345输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at &#x27;2&#x27;解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n示例 3：\n\n12345输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n0 &lt;= m, n &lt;= 3 * 104\n1 &lt;= Node.val &lt;= 105\n0 &lt;= skipA &lt;= m\n0 &lt;= skipB &lt;= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]\n\n进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？\n题解\n解题思路\n\n\n首先要注意，判断链表是否相交是看指针是否相等而不是数值是否相等。\n\n\n先分别计算出两个链表的长度并计算长度差 diff，之后让较长的链表向前移动 diff 步，这样两个链表就实现了尾部对齐（即操作两个链表的指针在同一起点上）。最后遍历两个数组判断是否有交点。\n\n\n思路比较简单，具体代码如下（已详细注释）。\n\n\n代码\n123456789101112131415161718192021222324252627282930313233343536373839struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) &#123;    //使用两个指针分别统计两个来链表的长度    struct ListNode* currA = headA;    struct ListNode* currB = headB;    int countA = 0, countB = 0;    while (currA) &#123;        countA++;        currA = currA-&gt;next;    &#125;    while (currB) &#123;        countB++;        currB = currB-&gt;next;    &#125;    //让 headA 指向较长的链表，便于后续操作    if (countB &gt; countA) &#123;        struct ListNode* temp = headA;        headA = headB;        headB = temp;    &#125;    //计算两个链表的长度差    int diff = countA &gt; countB ? countA - countB : countB - countA;    //让两个链表尾部对其    while (diff--) &#123;        headA = headA-&gt;next;    &#125;    //遍历两个来链表，若遇到相同说明相交，返回相交结点    while (headA) &#123;        if (headA == headB) &#123;            return headA;        &#125;        headA = headA-&gt;next;        headB = headB-&gt;next;    &#125;    //若无相交则返回空指针    return NULL;&#125;\n复杂度分析\n时间复杂度：O(n+m)​\n空间复杂度：O(1)\n总结\n一眼没看出来，看了题解发现和之前是一样的问题，被图给误导了，要把它看成单独的两条链表，然后有了思路就很简单了，也直接做了出来，看了一下之前写的题解，基本写法都一样，有一点小细节具体处理不同，不影响，直接用之前的题解了。\n","plink":"https://hs-zhangsan.github.io/leetcode/面试题02-07/"}]